00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/23/2018 12:34:12 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler I/O 
00000000                             3  * Written by :  touCANs
00000000                             4  * Date       :  5/1/18 - 
00000000                             5  * Description:  I/O functionality for the disassembler 
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000  287C 00008000             11      MOVEA.L #DISM_CODE,A4
00001006                            12      
00001006  43F9 000011BE             13      LEA     ADDR_PRMPT_STRT,A1
0000100C  103C 000E                 14      MOVE.B  #14,D0
00001010  4E4F                      15      TRAP    #15
00001012                            16  
00001012  43F9 00001230             17      LEA     buffer,A1       * Load buffer's effective address into A1
00001018  103C 0002                 18      MOVE.B  #2,D0           * get the starting address from the user as a string
0000101C                            19      
0000101C  4E4F                      20      TRAP    #15         
0000101E                            21      
0000101E                            22  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
0000101E  B27C 0004                 23      CMP     #4,D1           * minimum of a word for the address
00001022  6D00 008E                 24      BLT     ERROR_INV_INP   * invalid start address  
00001026                            25      
00001026  4EB9 0000105E             26      JSR     CONVERSION_LOOP * convert the starting address
0000102C                            27      
0000102C                            28  *** FULL STARTING ADDRESS HAS BEEN CONVERTED, STORE IN A6 AND GET ENDING ADDRESSS
0000102C  2C42                      29      MOVEA.L D2,A6           * move converted addr to A6 (A6 acts as iterator while disassembling)
0000102E  4282                      30      CLR.L   D2              * clear register D2 in preparation to hold the converted end address
00001030  4284                      31      CLR.L   D4              * clear register D4 to start the counter at 0 again
00001032                            32      
00001032  43F9 000011E1             33      LEA     ADDR_PRMPT_END,A1
00001038  103C 000E                 34      MOVE.B  #14,D0
0000103C  4E4F                      35      TRAP    #15
0000103E                            36      
0000103E  103C 0002                 37      MOVE.B  #2,D0           * get the ending address from the user as a string
00001042  4E4F                      38      TRAP    #15
00001044                            39      
00001044                            40  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
00001044  B27C 0004                 41      CMP     #4,D1           * minimum of a word for the address
00001048  6D00 0068                 42      BLT     ERROR_INV_INP   * invalid end address
0000104C                            43      
0000104C  4EB9 0000105E             44      JSR     CONVERSION_LOOP * convert the ending address
00001052  2A42                      45      MOVEA.L D2,A5           * move converted addr to A5 (compare A6 to A5 to know when to stop)
00001054  BDCD                      46      CMPA.L  A5,A6           * check if beginning address is >= end address. If so, display error
00001056  6C00 006A                 47      BGE     ERROR_END_LTE_BEG
0000105A  6000 0076                 48      BRA     MAIN_LOOP       * skip past the CONVERSION_LOOP subroutine to continue with the program
0000105E                            49      
0000105E                            50  
0000105E                            51  
0000105E                            52  *    ADDI.B  #1,D4           * offset our counter to start at 1
0000105E                            53  
0000105E                            54  
0000105E                            55  ;; ~~~~~~~~BEGINNING OF CONVERSION SUBROUTINE~~~~~~~~
0000105E                            56  CONVERSION_LOOP       
0000105E  1619                      57      MOVE.B  (A1)+,D3        * store the next thingy B
00001060                            58  *** Need to check for proper hex conversion 
00001060                            59  
00001060                            60  CHECK_NUM_MIN     ;; Checks if number is >= 30 (0) in ASCII
00001060  B67C 0030                 61      CMP     #ASC_NUM_MIN,D3 * Range of ASCII numbers: (2F >= 3A)[2F,3A] then subtract 30    
00001064  6C00 0006                 62      BGE     CHECK_NUM_MAX   * check if it's in range for x > 2F
00001068  6000 0048                 63      BRA     ERROR_INV_INP   * First condition not met, go to bad input error 
0000106C                            64      
0000106C                            65  CHECK_NUM_MAX     ;; Checks if number is <= 39 (9) in ASCII
0000106C  B67C 0039                 66      CMP     #ASC_NUM_MAX,D3
00001070  6F00 0020                 67      BLE     ASC_TO_NUM      * If condition for the range was met, do the math
00001074  4EF9 0000107A             68      JMP     CHECK_CHAR_MIN  * Second condition was not met, check if a character
0000107A                            69      
0000107A                            70  CHECK_CHAR_MIN    ;; Checks if number is >= 41 (A) in ASCII
0000107A  B67C 0041                 71      CMP     #ASC_CHAR_MIN,D3
0000107E  6C00 0006                 72      BGE     CHECK_CHAR_MAX  
00001082  6000 002E                 73      BRA     ERROR_INV_INP   * First condition not met, D3 < 41 = symbols. Go to bad input error
00001086                            74      
00001086                            75  CHECK_CHAR_MAX    ;; Checks if number is <= 46 (F) in ASCII
00001086  B67C 0046                 76      CMP     #ASC_CHAR_MAX,D3
0000108A  6F00 0010                 77      BLE     ASC_TO_CHAR     * Condition was met for A-F     
0000108E  6000 0022                 78      BRA     ERROR_INV_INP   * Greater than 46 = out of 16-bit system
00001092                            79      
00001092                            80  ASC_TO_NUM        ;; Converts a string digit into a hex value
00001092  0403 0030                 81      SUBI.B  #$30,D3
00001096  4EF9 000010A6             82      JMP     SHIFTS          * After this routine is finished, complete shifts/adds
0000109C                            83      
0000109C                            84  ASC_TO_CHAR       ;; Converts a string character into a hex value
0000109C  0403 0037                 85      SUBI.B  #$37,D3    
000010A0  4EF9 000010A6             86      JMP     SHIFTS          * Convert a string character into a hex value
000010A6                            87      
000010A6                            88  SHIFTS            ;; Shifts D2 left by four bits to make room for the newly converted hexabit
000010A6  E98A                      89      LSL.L   #4,D2           * Initial value in D2 shifted hexabit over to the left to make room   
000010A8  D403                      90      ADD.B   D3,D2           * Add modified value from D3 into D2.
000010AA                            91      
000010AA  5204                      92      ADD.B   #1,D4           * Increment counter by 1 
000010AC  B244                      93      CMP     D4,D1           * Check if we have already reached the end of the input. D4 = counter
000010AE  66AE                      94      BNE     CONVERSION_LOOP * Continue back to the loop if D4 != D1  
000010B0  4E75                      95      RTS
000010B2                            96  ;; ~~~~~~~~END OF CONVERSION SUBROUTINE~~~~~~~~
000010B2                            97      
000010B2                            98      
000010B2                            99      
000010B2                           100  ERROR_INV_INP ;; Prints the INVALID_INPUT error message to the console
000010B2  43F9 0000115E            101      LEA     INVALID_INPUT,A1
000010B8  103C 000D                102      MOVE.B  #13,D0
000010BC  4E4F                     103      TRAP    #15
000010BE  6000 0176                104      BRA     END_NOW
000010C2                           105      
000010C2                           106  ERROR_END_LTE_BEG ;; Prints the END_LTE_BEG (end <= to beginning) error message to the console.
000010C2  43F9 0000117B            107      LEA     END_LTE_BEG,A1
000010C8  103C 000D                108      MOVE.B  #13,D0
000010CC  4E4F                     109      TRAP    #15
000010CE  6000 0166                110      BRA     END_NOW
000010D2                           111    
000010D2                           112    
000010D2                           113  MAIN_LOOP
000010D2                           114      *BRA     END_NOW
000010D2  BDCD                     115      CMPA.L  A5,A6
000010D4  6C00 0160                116      BGE     END_NOW * End program
000010D8                           117      *MOVE.W  A6,D0   * Copy A6 location to restore after jump to SR
000010D8  4EB9 00001244            118      JSR     OP_DECODE
000010DE                           119      
000010DE                           120  PRINT_LOOP ;; Print the most recently decoded line
000010DE  103C 000D                121      MOVE.B  #13,D0
000010E2  4E4F                     122      TRAP    #15
000010E4  60EC                     123      BRA     MAIN_LOOP
000010E6                           124      
000010E6                           125  ;; print nops
000010E6                           126  PRINT_NOPS_TEST
000010E6  103C 000F                127      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
000010EA  143C 0010                128      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
000010EE                           129      * PRINT THE CURRENT ADDRESS
000010EE  220E                     130      MOVE.L  A6,D1
000010F0  4E4F                     131      TRAP    #15
000010F2  4281                     132      CLR.L   D1          * clear D1 so that it holds just the data on the next print
000010F4                           133      
000010F4  43F9 0000115B            134      LEA     COLON_SPACE,A1
000010FA  103C 000E                135      MOVE.B  #14,D0
000010FE  4E4F                     136      TRAP    #15
00001100                           137      
00001100  103C 0001                138      MOVE.B  #1,D0   * Print string, no CRLF
00001104                           139      
00001104                           140      
00001104                           141      
00001104                           142      
00001104                           143  
00001104                           144  ;; ~~~~~~~~BEGINNING OF PRINT LOOP~~~~~~~~   
00001104                           145  PRINT_IT          ;; Placeholder for now; just prints all data between start and end
00001104  43F9 00001203            146      LEA     PRINT_IT_STRING,A1
0000110A  103C 000D                147      MOVE.B  #13,D0
0000110E  4E4F                     148      TRAP    #15
00001110                           149      
00001110                           150  PRINT_IT_LOOP
00001110  103C 000F                151      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
00001114  143C 0010                152      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
00001118                           153      * PRINT THE CURRENT ADDRESS
00001118  220E                     154      MOVE.L  A6,D1
0000111A  4E4F                     155      TRAP    #15
0000111C  4281                     156      CLR.L   D1          * clear D1 so that it holds just the data on the next print
0000111E                           157      
0000111E  43F9 0000115B            158      LEA     COLON_SPACE,A1
00001124  103C 000E                159      MOVE.B  #14,D0
00001128  4E4F                     160      TRAP    #15
0000112A                           161      
0000112A  221E                     162      MOVE.L  (A6)+,D1    * move the data at the pointer into D1 and increment.
0000112C  103C 000F                163      MOVE.B  #15,D0      * Trap task 15 to print a signed number in the base in D2
00001130  4E4F                     164      TRAP    #15
00001132                           165      
00001132                           166      * Print a new line
00001132  43F9 00001152            167      LEA     NEW_LINE,A1
00001138  103C 000D                168      MOVE.B  #13,D0
0000113C  4E4F                     169      TRAP    #15
0000113E                           170      
0000113E                           171      * Check if end address has been reached
0000113E  BDCD                     172      CMP.L   A5,A6
00001140  6FCE                     173      BLE     PRINT_IT_LOOP
00001142                           174  ;; ~~~~~~~~END OF PRINT LOOP~~~~~~~~
00001142                           175  
00001142                           176  
00001142                           177      
00001142                           178      
00001142  43F9 00001155            179      LEA     DONE_MSG,A1
00001148  103C 000D                180      MOVE.B  #13,D0
0000114C  4E4F                     181      TRAP    #15
0000114E                           182  
0000114E  FFFF FFFF                183      SIMHALT             ; halt simulator
00001152                           184  
00001152                           185  * Put variables and constants here
00001152                           186  
00001152                           187  *** ASCII constants used in the conversion loop. Subtract these from an ASCII character to get its
00001152                           188  *** real hex value (depending on whether it's a digit or a character).
00001152  =00000030                189  ASC_NUM_MIN     EQU     $30     * ASCII key for 0
00001152  =00000039                190  ASC_NUM_MAX     EQU     $39     * ASCII key for 9
00001152  =00000041                191  ASC_CHAR_MIN    EQU     $41     * ASCII key for A
00001152  =00000046                192  ASC_CHAR_MAX    EQU     $46     * ASCII key for F
00001152                           193  
00001152                           194  *** Message strings
00001152                           195      * Temporary; used for debugging and testing
00001152= 00 0D 0A                 196  NEW_LINE        DC.B    '',0,CR,LF
00001155                           197      * Temporary; used for debugging and testing
00001155= 44 6F 6E 65 2E 00        198  DONE_MSG        DC.B    'Done.',0
0000115B                           199      * Temporary; used for debugging and testing
0000115B= 3A 20 00                 200  COLON_SPACE     DC.B    ': ',0
0000115E= 49 6E 76 61 6C 69 ...    201  INVALID_INPUT   DC.B    'Invalid input! Out of Range.',0
0000117B= 49 6E 76 61 6C 69 ...    202  END_LTE_BEG     DC.B    'Invalid input! End address is less than or equal to start address.',0  
000011BE= 45 6E 74 65 72 20 ...    203  ADDR_PRMPT_STRT DC.B    'Enter a starting address in hex: $',0
000011E1= 45 6E 74 65 72 20 ...    204  ADDR_PRMPT_END  DC.B    'Enter an ending address in hex: $',0
00001203= 49 20 61 6D 20 61 ...    205  PRINT_IT_STRING DC.B    'I am a PRINT_IT string. It is printing time!',0
00001230  =0000000A                206  LF              EQU      $0A
00001230  =0000000D                207  CR              EQU      $0D
00001230                           208  
00001230= 00000001                 209  buffer  DC.L    1
00001234                           210  
00001234  =00008000                211  DISM_CODE     EQU     $8000 * Where to write disassembled code
00001234                           212      
00001234  4E71                     213      NOP
00001236                           214  
00001236                           215  END_NOW
00001236  43F8 1155                216      LEA     DONE_MSG,A1
0000123A  103C 0001                217      MOVE.B  #1,D0
0000123E  4E4F                     218      TRAP    #15
00001240  43F8 1230                219      LEA     buffer,A1
00001244                           220      
00001244                           221      INCLUDE 'OP.X68'
00001244                           222  
00001244                           223  ;; ~*~*~*~*~*~*~*~BEGIN OPCODE MODULE~*~*~*~*~*~*~*~
00001244                           224  
00001244                           225  OP_DECODE
00001244  3A1E                     226      MOVE.W  (A6)+,D5     * Load the next opcode to decode into D5, incrementing
00001246                           227      * NOTE: A6 now points at either the next opcode or imm. data for EA part
00001246                           228      
00001246                           229      * is it NOP?
00001246  BA7C 4E71                230      CMP.W   #CODE_NOP,D5
0000124A  6700 021E                231      BEQ     DO_NOP      * After execution of this branch, will return to I/O
0000124E                           232      
0000124E                           233      * is it RTS?
0000124E  BA7C 4E75                234      CMP.W   #CODE_RTS,D5
00001252  6700 0228                235      BEQ     DO_RTS      * After execution of this branch, will return to I/O
00001256                           236      
00001256                           237      ** Not NOP or RTS, check bit-by-bit to narrow down
00001256                           238      
00001256  0805 000F                239      BTST.L  #15,D5       * Test the most significant bit of the command
0000125A  6700 000C                240      BEQ     OXXX_BRA     * Branch to opcodes starting with zero     
0000125E  6000 00FA                241      BRA     IXXX_BRA     * Branch to opcodes starting with a one  ******** COME BAK
00001262                           242     
00001262  6000 0206                243      BRA     DO_NOP
00001266  4E75                     244      RTS * Return to I/O module (temporary; will go to EA module eventually)
00001268                           245      
00001268                           246  OXXX_BRA
00001268  0805 000E                247      BTST.L  #14,D5      * Test the second bit 
0000126C  6700 0006                248      BEQ     OOXX_BRA    * Branch to opcodes starting with 00
00001270  6000 0012                249      BRA     OIXX_BRA    * Branch to opcodes starting with 01   *** COME BAK
00001274                           250  
00001274                           251  OOXX_BRA
00001274  0805 000D                252      BTST.L  #13,D5          * Test the second bit 
00001278  6700 0016                253      BEQ     OOOX_BRA        * Branch to opcodes starting with 000
0000127C  6000 001E                254      BRA     OOIX_BRA        * Might be MOVE, MOVEA
00001280  6000 0242                255      BRA     PRINT_INVALID_MSG
00001284                           256  OIXX_BRA
00001284  0805 000D                257      BTST.L  #13,D5
00001288  6700 008A                258      BEQ     OIOX_BRA            * CLR, JSR, MOVEM, LEA, ADDQ, SUBQ
0000128C  6000 0092                259      BRA     OIIX_BRA            * BCC, OR MOVEQ
00001290                           260  OOOX_BRA
00001290  0805 000C                261      BTST.L  #12,D5              * Test the second bit 
00001294  6700 0012                262      BEQ     OOOO_BRA            * Decision for SUBI or ADDI
00001298  6000 0028                263      BRA     OOOI_BRA            * MOVE and MOVEA (B)
0000129C                           264  OOIX_BRA
0000129C  0805 000C                265      BTST.L  #12,D5              * Test the second bit 
000012A0  6700 0032                266      BEQ     OOIO_BRA            * MOVE or MOVEA need to be handled here (W)
000012A4  6000 004E                267      BRA     OOII_BRA            * MOVE or MOVEA need to be handled here (L)
000012A8                           268  
000012A8                           269  OOOO_BRA                        * tests for ADDI or SUBI
000012A8  343C 0F00                270      MOVE.W  #ADDSUBI_MASK,D2   * Load mask for ADDI temporarily into register for AND operation
000012AC  C445                     271      AND.W   D5,D2               * AND with current opcode data and store into D2
000012AE  B47C 0600                272      CMP.W   #$0600,D2           * Result of mask should be 0060 if the code is ADDi
000012B2  6700 0126                273      BEQ     DO_ADDI     
000012B6  B47C 0400                274      CMP.W   #$0400,D2           * SUBI and ADDI  have the same bitmask.
000012BA  6700 0166                275      BEQ     DO_SUBI
000012BE  6000 0204                276      BRA     PRINT_INVALID_MSG
000012C2                           277  OOOI_BRA                        * MOVE and MOVEA need to be handled here (B)
000012C2  343C 3000                278      MOVE.W  #MOVE_MASK,D2
000012C6  C445                     279      AND.W   D5,D2
000012C8  B47C 1000                280      CMP.W   #$1000,D2           * is it a move byte?
000012CC  6700 0090                281      BEQ     DO_MOVE_B           
000012D0                           282  
000012D0  6000 01F2                283      BRA     PRINT_INVALID_MSG   *neither MoveA or Move? BADDDD
000012D4                           284  OOIO_BRA                        * MOVE and MOVEA need to be handled here (W)
000012D4  343C 31C0                285      MOVE.W  #MOVEA_MASK,D2
000012D8  C445                     286      AND.W   D5,D2
000012DA  B47C 2040                287      CMP.W   #$2040,D2           * is it a moveA word?
000012DE  6700 0090                288      BEQ     DO_MOVEA_W          
000012E2                           289  
000012E2  343C 3000                290      MOVE.W  #MOVE_MASK,D2
000012E6  C445                     291      AND.W   D5,D2
000012E8  B47C 2000                292      CMP.W   #$2000,D2           * is it a move word?
000012EC  6700 0094                293      BEQ     DO_MOVE_W           
000012F0                           294  
000012F0  6000 01D2                295      BRA     PRINT_INVALID_MSG
000012F4                           296  OOII_BRA                        * MOVE and MOVEA need to be handled here (L)
000012F4  343C 31C0                297      MOVE.W  #MOVEA_MASK,D2
000012F8  C445                     298      AND.W   D5,D2
000012FA  B47C 3040                299      CMP.W   #$3040,D2           * is it a moveA long?
000012FE  6700 0094                300      BEQ     DO_MOVEA_L          
00001302                           301  
00001302  343C 3000                302      MOVE.W  #MOVE_MASK,D2
00001306  C445                     303      AND.W   D5,D2
00001308  B47C 3000                304      CMP.W   #$3000,D2           * is it a move long?
0000130C  6700 0098                305      BEQ     DO_MOVE_L           
00001310                           306  
00001310  6000 01B2                307      BRA     PRINT_INVALID_MSG
00001314                           308  OIOX_BRA
00001314  0805 000C                309      BTST.L  #12,D5
00001318  6700 0012                310      BEQ     OIOO_BRA    * CLR, JSR, MOVEM, LEA   
0000131C  6000 0116                311      BRA     DO_ADDQ     * ADDQ 
00001320                           312  OIIX_BRA
00001320                           313      *check for MOVEQ and BCC here, which is 0110 always. there is no 0111
00001320  0805 000C                314      BTST.L  #12,D5
00001324  6700 00EA                315      BEQ     DO_Bcc            * BCC happens here, have to narrow it down to which one!
00001328  6000 0176                316      BRA     DO_MOVEQ   
0000132C                           317  OIOO_BRA
0000132C                           318      ** Test for JSR
0000132C  343C 0FC0                319      MOVE.W  #JSR_MASK,D2 * Load mask temporarily into register for ANDing
00001330  C445                     320      AND.W   D5,D2        * AND with the current opcode data
00001332  B47C 0E80                321      CMP.W   #$0E80,D2    * Result of mask should be 0E80 if code is JSR
00001336  6700 017A                322      BEQ     DO_JSR       *
0000133A                           323  
0000133A  343C 0F00                324      MOVE.W  #CLR_MASK,D2
0000133E  C445                     325      AND.W   D5,D2
00001340  B47C 0200                326      CMP.W   #$0200,D2              * IS IT CLR?
00001344  6700 0100                327      BEQ     DO_CLR
00001348                           328  
00001348  343C 01C0                329      MOVE.W  #LEA_MASK,D2
0000134C  C445                     330      AND     D5,D2
0000134E  B47C 01C0                331      CMP.W   #$01C0,D2              *EQUAL TO LEA?
00001352  6700 0104                332      BEQ.W   DO_LEA
00001356  6000 017E                333      BRA     PRINT_OIOO_ERROR       * if not RTS, not JSR, CLR, or LEA, then its invalid. 
0000135A                           334  
0000135A                           335  IXXX_BRA
0000135A  6000 018C                336      BRA     PRINT_COME_BACK_MSG   * temporary until further development of right branch
0000135E                           337      
0000135E                           338  DO_MOVE_B
0000135E  47F9 00001542            339      LEA     S_MOVE_B,A3
00001364  1E3C 002A                340      MOVE.B  #$2A,D7         * for now, temporarily calling this mnemonic number 2, section a (which is a byte)
00001368                           341      ** Eventually, EA Module will be called here
00001368  4EB9 000014FA            342      JSR     WRITE
0000136E  4E75                     343      RTS
00001370                           344  DO_MOVEA_W
00001370  47F9 00001549            345      LEA     S_MOVEA_W,A3
00001376  1E3C 003B                346      MOVE.B  #$3B,D7         * for now, temporarily calling this mnemonic number 3, section b (which is a word)
0000137A                           347      ** Eventually, EA Module will be called here
0000137A  4EB9 000014FA            348      JSR     WRITE
00001380  4E75                     349      RTS
00001382                           350  DO_MOVE_W
00001382  47F9 00001551            351      LEA     S_MOVE_W,A3
00001388  1E3C 002B                352      MOVE.B  #$2B,D7         * for now, temporarily calling this mnemonic number 2, section b (which is a word)
0000138C                           353      ** Eventually, EA Module will be called here
0000138C  4EB9 000014FA            354      JSR     WRITE
00001392  4E75                     355      RTS
00001394                           356  DO_MOVEA_L
00001394  47F9 00001558            357      LEA     S_MOVEA_L,A3
0000139A  1E3C 003C                358      MOVE.B  #$3C,D7         * for now, temporarily calling this mnemonic number 3, section c (which is a long)
0000139E                           359      ** Eventually, EA Module will be called here
0000139E  4EB9 000014FA            360      JSR     WRITE
000013A4  4E75                     361      RTS
000013A6                           362  DO_MOVE_L
000013A6  47F9 00001560            363      LEA     S_MOVE_L,A3
000013AC  1E3C 002C                364      MOVE.B  #$2C,D7         * for now, temporarily calling this mnemonic number 2, section c (which is a long)
000013B0                           365      ** Eventually, EA Module will be called here
000013B0  4EB9 000014FA            366      JSR     WRITE
000013B6  4E75                     367      RTS
000013B8                           368  
000013B8                           369  DO_BCC_CASE
000013B8  343C 0F00                370      MOVE.W  #Bcc_MASK,D2
000013BC  C445                     371      AND     D5,D2
000013BE  B47C 0E00                372      CMP.W   #$0E00,D2                * Is it BGT?
000013C2  6700 0028                373      BEQ.W   DO_BGT
000013C6                           374      
000013C6  B47C 0F00                375      CMP.W   #$0F00,D2                * Is it BLE?
000013CA  6700 0032                376      BEQ.W   DO_BLE
000013CE                           377  
000013CE  B47C 0400                378      CMP.W   #$0400,D2                * Is it BCC?
000013D2  6700 003C                379      BEQ.W   DO_BCC
000013D6                           380  
000013D6  6000 00EC                381      BRA     PRINT_INVALID_MSG        * none of these options? not required or invalid
000013DA                           382  
000013DA                           383  DO_ADDI
000013DA  47F9 0000151E            384      LEA     S_ADDI,A3
000013E0  1E3C 0008                385      MOVE.B  #8,D7
000013E4                           386      ** Eventually, EA Module will be called here
000013E4  4EB9 000014FA            387      JSR     WRITE
000013EA  4E75                     388      RTS
000013EC                           389  DO_BGT
000013EC  47F9 00001536            390      LEA     S_BGT,A3
000013F2  1E3C 001A                391      MOVE.B  #26,D7
000013F6                           392      ** Eventually, EA Module will be called here
000013F6  4EB9 000014FA            393      JSR     WRITE
000013FC  4E75                     394      RTS
000013FE                           395  DO_BLE
000013FE  47F9 0000153A            396      LEA     S_BLE,A3
00001404  1E3C 001B                397      MOVE.B  #27,D7
00001408                           398      ** Eventually, EA Module will be called here
00001408  4EB9 000014FA            399      JSR     WRITE
0000140E  4E75                     400      RTS
00001410                           401  DO_BCC
00001410  47F9 0000153E            402      LEA     S_BCC,A3
00001416  1E3C 001C                403      MOVE.B  #28,D7
0000141A                           404      ** Eventually, EA Module will be called here
0000141A  4EB9 000014FA            405      JSR     WRITE
00001420  4E75                     406      RTS
00001422                           407  DO_SUBI
00001422  47F9 00001523            408      LEA     S_SUBI,A3
00001428  1E3C 000B                409      MOVE.B  #11,D7
0000142C                           410      ** Eventually, EA Module will be called here
0000142C  4EB9 000014FA            411      JSR     WRITE
00001432  4E75                     412      RTS
00001434                           413  DO_ADDQ
00001434                           414      *Check for full opcode for 11 and onwards. if invalid, print the message
00001434  47F9 00001519            415      LEA     S_ADDQ,A3
0000143A  1E3C 0009                416      MOVE.B  #9,D7
0000143E                           417      ** Eventually, EA Module will be called here
0000143E  4EB9 000014FA            418      JSR     WRITE
00001444  4E75                     419      RTS
00001446                           420  DO_CLR
00001446  47F9 00001528            421      LEA     S_CLR,A3
0000144C  1E3C 0010                422      MOVE.B  #16,D7
00001450                           423      ** Eventually, EA Module will be called here
00001450  4EB9 000014FA            424      JSR     WRITE
00001456  4E75                     425      RTS
00001458                           426  DO_LEA
00001458  47F9 0000152C            427      LEA     S_LEA,A3    * Load the NOP string into A3 for WRITE subroutine
0000145E  1E3C 000F                428      MOVE.B  #15,D7       * Store key for op code for EA module
00001462                           429      ** Eventually, EA Module will be called here
00001462  4EB9 000014FA            430      JSR     WRITE       * Jump to WRITE subroutine
00001468  4E75                     431      RTS                 * Return to I/O module 
0000146A                           432  DO_NOP
0000146A  47F9 00001508            433      LEA     S_NOP,A3    * Load the NOP string into A3 for WRITE subroutine
00001470  1E3C 0001                434      MOVE.B  #1,D7       * Store key for op code for EA module
00001474                           435      ** Eventually, EA Module will be called here
00001474  4EB9 000014FA            436      JSR     WRITE       * Jump to WRITE subroutine
0000147A  4E75                     437      RTS                 * Return to I/O module 
0000147C                           438  DO_RTS
0000147C  47F9 0000150C            439      LEA     S_RTS,A3    * Load the RTS string into A3 for WRITE subroutine
00001482  1E3C 001E                440      MOVE.B  #30,D7      * Store key for op code for EA module
00001486                           441      ** Eventually, EA Module will be called here
00001486  4EB9 000014FA            442      JSR     WRITE       * Jump to WRITE subroutine
0000148C  4E75                     443      RTS                 * Return to the I/O module bra op_decode  
0000148E                           444  DO_MOVE
0000148E  47F9 00001510            445      LEA     S_MOVE,A3
00001494  1E3C 0002                446      MOVE.B  #2,D7
00001498                           447      ** Eventually, EA Module will be called here
00001498  4EB9 000014FA            448      JSR     WRITE
0000149E  4E75                     449      RTS
000014A0                           450  DO_MOVEQ
000014A0  47F9 00001530            451      LEA     S_MOVEQ,A3
000014A6  1E3C 0004                452      MOVE.B  #4,D7
000014AA  4EB9 000014FA            453      JSR     WRITE
000014B0  4E75                     454      RTS
000014B2                           455  DO_JSR
000014B2  47F9 00001515            456      LEA     S_JSR,A3
000014B8  1E3C 001B                457      MOVE.B  #27,D7
000014BC                           458      ** Eventually, NOCK will be called here
000014BC  4EB9 000014FA            459      JSR     WRITE
000014C2  4E75                     460      RTS
000014C4                           461  PRINT_INVALID_MSG
000014C4  47F9 00001567            462      LEA     INVALID,A3
000014CA  1E3C 0000                463      MOVE.B  #0,D7
000014CE                           464      ** Eventually, NOCK will be called here
000014CE  4EB9 000014FA            465      JSR     WRITE
000014D4  4E75                     466      RTS
000014D6                           467  PRINT_OIOO_ERROR
000014D6  47F9 000015B6            468      LEA     BAD_OIOO,A3
000014DC  1E3C 0000                469      MOVE.B  #0,D7
000014E0                           470      ** Eventually, NOCK will be called here
000014E0  4EB9 000014FA            471      JSR     WRITE
000014E6  4E75                     472      RTS
000014E8                           473  PRINT_COME_BACK_MSG
000014E8  47F9 00001593            474      LEA     COMEBK,A3
000014EE  1E3C 0000                475      MOVE.B  #0,D7
000014F2                           476      ** Eventually, NOCK will be called here
000014F2  4EB9 000014FA            477      JSR     WRITE
000014F8  4E75                     478      RTS
000014FA                           479  WRITE   * Writes string pointed to by A3 to memory pointed to by A1
000014FA  224C                     480      MOVEA.L A4,A1     * Save the position of A1 before writing (for I/0)
000014FC                           481  WRITE_LOOP
000014FC  18DB                     482      MOVE.B  (A3)+,(A4)+     * Write one byte and increment
000014FE  0C13 0000                483      CMP.B   #0,(A3)         * Are we at the null terminator?
00001502  66F8                     484      BNE     WRITE_LOOP      * If not, keep going
00001504  18DB                     485      MOVE.B  (A3)+,(A4)+     * Write the null terminator before exiting
00001506  4E75                     486      RTS                     * Executes once null terminator was reached
00001508                           487      
00001508                           488  ;; ~~~~~~~~STRING CONSTANTS~~~~~~~~
00001508                           489  
00001508  =00004E71                490  CODE_NOP    EQU     $4E71
00001508  =00004E75                491  CODE_RTS    EQU     $4E75
00001508                           492  
00001508  =00002000                493  A4_PREV     SET     $2000
00001508                           494  
00001508= 4E 4F 50 00              495  S_NOP       DC.B    'NOP',0
0000150C= 52 54 53 00              496  S_RTS       DC.B    'RTS',0
00001510= 4D 4F 56 45 00           497  S_MOVE      DC.B    'MOVE',0
00001515= 4A 53 52 00              498  S_JSR       DC.B    'JSR',0
00001519= 41 44 44 51 00           499  S_ADDQ      DC.B    'ADDQ',0
0000151E= 41 44 44 49 00           500  S_ADDI      DC.B    'ADDI',0
00001523= 53 55 42 49 00           501  S_SUBI      DC.B    'SUBI',0
00001528= 43 4C 52 00              502  S_CLR       DC.B    'CLR',0
0000152C= 4C 45 41 00              503  S_LEA       DC.B    'LEA',0    
00001530= 4D 4F 56 45 51 00        504  S_MOVEQ     DC.B    'MOVEQ',0
00001536= 42 47 54 00              505  S_BGT       DC.B    'BGT',0
0000153A= 42 4C 45 00              506  S_BLE       DC.B    'BLE',0
0000153E= 42 43 43 00              507  S_BCC       DC.B    'BCC',0
00001542= 4D 4F 56 45 2E 42 00     508  S_MOVE_B    DC.B    'MOVE.B',0
00001549= 4D 4F 56 45 41 2E ...    509  S_MOVEA_W   DC.B    'MOVEA.W',0
00001551= 4D 4F 56 45 2E 57 00     510  S_MOVE_W    DC.B    'MOVE.W',0
00001558= 4D 4F 56 45 41 2E ...    511  S_MOVEA_L   DC.B    'MOVEA.L',0
00001560= 4D 4F 56 45 2E 4C 00     512  S_MOVE_L    DC.B    'MOVE.L',0
00001567                           513  
00001567                           514  
00001567= 49 4E 56 41 4C 49 ...    515  INVALID     DC.B    'INVALID OPCODE. LETS FIX THIS MESSAGE LATER',0
00001593= 43 6F 6D 65 20 62 ...    516  COMEBK      DC.B    'Come back to me pls dont forget me',0 
000015B6= 42 61 64 20 4F 49 ...    517  BAD_OIOO    DC.B    'Bad OIOO maybe not JSR,RTS,CLR,LEA.. who knows.',0
000015E6                           518  
000015E6  =00000FC0                519  JSR_MASK        EQU     %0000111111000000
000015E6  =00000F00                520  ADDSUBI_MASK    EQU     %0000111100000000       ** come back and fix this to be the same but diferent comparisons 
000015E6  =00000000                521  BYTE_MASK       EQU     %0000000000000000       * Not sure if this is needed
000015E6  =00000040                522  WORD_MASK       EQU     %0000000001000000       * not sure if this is needed
000015E6  =00000080                523  LONG_MASK       EQU     %0000000010000000       * not sure if this is needed
000015E6  =00000F00                524  CLR_MASK        EQU     %0000111100000000
000015E6  =000001C0                525  LEA_MASK        EQU     %0000000111000000
000015E6  =00000F00                526  Bcc_MASK        EQU     %0000111100000000
000015E6                           527  
000015E6  =000031C0                528  MOVEA_MASK      EQU     %0011000111000000
000015E6  =00003000                529  MOVE_MASK       EQU     %0011000000000000
000015E6                           530  ;; ~*~*~*~*~*~*~*~END OPCODE MODULE~*~*~*~*~*~*~*~
000015E6                           531  
000015E6                           532  
000015E6                           533  -------------------- end include --------------------
000015E6                           534      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A4_PREV             2000
ADDR_PRMPT_END      11E1
ADDR_PRMPT_STRT     11BE
ADDSUBI_MASK        F00
ASC_CHAR_MAX        46
ASC_CHAR_MIN        41
ASC_NUM_MAX         39
ASC_NUM_MIN         30
ASC_TO_CHAR         109C
ASC_TO_NUM          1092
BAD_OIOO            15B6
BCC_MASK            F00
BUFFER              1230
BYTE_MASK           0
CHECK_CHAR_MAX      1086
CHECK_CHAR_MIN      107A
CHECK_NUM_MAX       106C
CHECK_NUM_MIN       1060
CLR_MASK            F00
CODE_NOP            4E71
CODE_RTS            4E75
COLON_SPACE         115B
COMEBK              1593
CONVERSION_LOOP     105E
CR                  D
DISM_CODE           8000
DONE_MSG            1155
DO_ADDI             13DA
DO_ADDQ             1434
DO_BCC              1410
DO_BCC_CASE         13B8
DO_BGT              13EC
DO_BLE              13FE
DO_CLR              1446
DO_JSR              14B2
DO_LEA              1458
DO_MOVE             148E
DO_MOVEA_L          1394
DO_MOVEA_W          1370
DO_MOVEQ            14A0
DO_MOVE_B           135E
DO_MOVE_L           13A6
DO_MOVE_W           1382
DO_NOP              146A
DO_RTS              147C
DO_SUBI             1422
END_LTE_BEG         117B
END_NOW             1236
ERROR_END_LTE_BEG   10C2
ERROR_INV_INP       10B2
INVALID             1567
INVALID_INPUT       115E
IXXX_BRA            135A
JSR_MASK            FC0
LEA_MASK            1C0
LF                  A
LONG_MASK           80
MAIN_LOOP           10D2
MOVEA_MASK          31C0
MOVE_MASK           3000
NEW_LINE            1152
OIIX_BRA            1320
OIOO_BRA            132C
OIOX_BRA            1314
OIXX_BRA            1284
OOII_BRA            12F4
OOIO_BRA            12D4
OOIX_BRA            129C
OOOI_BRA            12C2
OOOO_BRA            12A8
OOOX_BRA            1290
OOXX_BRA            1274
OP_DECODE           1244
OXXX_BRA            1268
PRINT_COME_BACK_MSG  14E8
PRINT_INVALID_MSG   14C4
PRINT_IT            1104
PRINT_IT_LOOP       1110
PRINT_IT_STRING     1203
PRINT_LOOP          10DE
PRINT_NOPS_TEST     10E6
PRINT_OIOO_ERROR    14D6
SHIFTS              10A6
START               1000
S_ADDI              151E
S_ADDQ              1519
S_BCC               153E
S_BGT               1536
S_BLE               153A
S_CLR               1528
S_JSR               1515
S_LEA               152C
S_MOVE              1510
S_MOVEA_L           1558
S_MOVEA_W           1549
S_MOVEQ             1530
S_MOVE_B            1542
S_MOVE_L            1560
S_MOVE_W            1551
S_NOP               1508
S_RTS               150C
S_SUBI              1523
WORD_MASK           40
WRITE               14FA
WRITE_LOOP          14FC
