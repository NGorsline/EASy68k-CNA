00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/25/2018 11:13:41 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler I/O 
00000000                             3  * Written by :  touCANs
00000000                             4  * Date       :  5/1/18 - 
00000000                             5  * Description:  I/O functionality for the disassembler 
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000  287C 00008000             11      MOVEA.L #DISM_CODE,A4
00001006                            12      
00001006  43F9 000011C6             13      LEA     ADDR_PRMPT_STRT,A1
0000100C  103C 000E                 14      MOVE.B  #14,D0
00001010  4E4F                      15      TRAP    #15
00001012                            16  
00001012  43F9 0000123A             17      LEA     buffer,A1       * Load buffer's effective address into A1
00001018  103C 0002                 18      MOVE.B  #2,D0           * get the starting address from the user as a string
0000101C                            19      
0000101C  4E4F                      20      TRAP    #15         
0000101E                            21      
0000101E                            22  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
0000101E  B27C 0004                 23      CMP     #4,D1           * minimum of a word for the address
00001022  6D00 008E                 24      BLT     ERROR_INV_INP   * invalid start address  
00001026                            25      
00001026  4EB9 0000105E             26      JSR     CONVERSION_LOOP * convert the starting address
0000102C                            27      
0000102C                            28  *** FULL STARTING ADDRESS HAS BEEN CONVERTED, STORE IN A6 AND GET ENDING ADDRESSS
0000102C  2C42                      29      MOVEA.L D2,A6           * move converted addr to A6 (A6 acts as iterator while disassembling)
0000102E  4282                      30      CLR.L   D2              * clear register D2 in preparation to hold the converted end address
00001030  4284                      31      CLR.L   D4              * clear register D4 to start the counter at 0 again
00001032                            32      
00001032  43F9 000011E9             33      LEA     ADDR_PRMPT_END,A1
00001038  103C 000E                 34      MOVE.B  #14,D0
0000103C  4E4F                      35      TRAP    #15
0000103E                            36      
0000103E  103C 0002                 37      MOVE.B  #2,D0           * get the ending address from the user as a string
00001042  4E4F                      38      TRAP    #15
00001044                            39      
00001044                            40  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
00001044  B27C 0004                 41      CMP     #4,D1           * minimum of a word for the address
00001048  6D00 0068                 42      BLT     ERROR_INV_INP   * invalid end address
0000104C                            43      
0000104C  4EB9 0000105E             44      JSR     CONVERSION_LOOP * convert the ending address
00001052  2A42                      45      MOVEA.L D2,A5           * move converted addr to A5 (compare A6 to A5 to know when to stop)
00001054  BDCD                      46      CMPA.L  A5,A6           * check if beginning address is >= end address. If so, display error
00001056  6C00 006A                 47      BGE     ERROR_END_LTE_BEG
0000105A  6000 0076                 48      BRA     MAIN_LOOP       * skip past the CONVERSION_LOOP subroutine to continue with the program
0000105E                            49      
0000105E                            50  
0000105E                            51  
0000105E                            52  *    ADDI.B  #1,D4           * offset our counter to start at 1
0000105E                            53  
0000105E                            54  
0000105E                            55  ;; ~~~~~~~~BEGINNING OF CONVERSION SUBROUTINE~~~~~~~~
0000105E                            56  CONVERSION_LOOP       
0000105E  1619                      57      MOVE.B  (A1)+,D3        * store the next thingy B
00001060                            58  *** Need to check for proper hex conversion 
00001060                            59  
00001060                            60  CHECK_NUM_MIN     ;; Checks if number is >= 30 (0) in ASCII
00001060  B67C 0030                 61      CMP     #ASC_NUM_MIN,D3 * Range of ASCII numbers: (2F >= 3A)[2F,3A] then subtract 30    
00001064  6C00 0006                 62      BGE     CHECK_NUM_MAX   * check if it's in range for x > 2F
00001068  6000 0048                 63      BRA     ERROR_INV_INP   * First condition not met, go to bad input error 
0000106C                            64      
0000106C                            65  CHECK_NUM_MAX     ;; Checks if number is <= 39 (9) in ASCII
0000106C  B67C 0039                 66      CMP     #ASC_NUM_MAX,D3
00001070  6F00 0020                 67      BLE     ASC_TO_NUM      * If condition for the range was met, do the math
00001074  4EF9 0000107A             68      JMP     CHECK_CHAR_MIN  * Second condition was not met, check if a character
0000107A                            69      
0000107A                            70  CHECK_CHAR_MIN    ;; Checks if number is >= 41 (A) in ASCII
0000107A  B67C 0041                 71      CMP     #ASC_CHAR_MIN,D3
0000107E  6C00 0006                 72      BGE     CHECK_CHAR_MAX  
00001082  6000 002E                 73      BRA     ERROR_INV_INP   * First condition not met, D3 < 41 = symbols. Go to bad input error
00001086                            74      
00001086                            75  CHECK_CHAR_MAX    ;; Checks if number is <= 46 (F) in ASCII
00001086  B67C 0046                 76      CMP     #ASC_CHAR_MAX,D3
0000108A  6F00 0010                 77      BLE     ASC_TO_CHAR     * Condition was met for A-F     
0000108E  6000 0022                 78      BRA     ERROR_INV_INP   * Greater than 46 = out of 16-bit system
00001092                            79      
00001092                            80  ASC_TO_NUM        ;; Converts a string digit into a hex value
00001092  0403 0030                 81      SUBI.B  #$30,D3
00001096  4EF9 000010A6             82      JMP     SHIFTS          * After this routine is finished, complete shifts/adds
0000109C                            83      
0000109C                            84  ASC_TO_CHAR       ;; Converts a string character into a hex value
0000109C  0403 0037                 85      SUBI.B  #$37,D3    
000010A0  4EF9 000010A6             86      JMP     SHIFTS          * Convert a string character into a hex value
000010A6                            87      
000010A6                            88  SHIFTS            ;; Shifts D2 left by four bits to make room for the newly converted hexabit
000010A6  E98A                      89      LSL.L   #4,D2           * Initial value in D2 shifted hexabit over to the left to make room   
000010A8  D403                      90      ADD.B   D3,D2           * Add modified value from D3 into D2.
000010AA                            91      
000010AA  5204                      92      ADD.B   #1,D4           * Increment counter by 1 
000010AC  B244                      93      CMP     D4,D1           * Check if we have already reached the end of the input. D4 = counter
000010AE  66AE                      94      BNE     CONVERSION_LOOP * Continue back to the loop if D4 != D1  
000010B0  4E75                      95      RTS
000010B2                            96  ;; ~~~~~~~~END OF CONVERSION SUBROUTINE~~~~~~~~
000010B2                            97      
000010B2                            98      
000010B2                            99      
000010B2                           100  ERROR_INV_INP ;; Prints the INVALID_INPUT error message to the console
000010B2  43F9 00001166            101      LEA     INVALID_INPUT,A1
000010B8  103C 000D                102      MOVE.B  #13,D0
000010BC  4E4F                     103      TRAP    #15
000010BE  6000 0180                104      BRA     END_NOW
000010C2                           105      
000010C2                           106  ERROR_END_LTE_BEG ;; Prints the END_LTE_BEG (end <= to beginning) error message to the console.
000010C2  43F9 00001183            107      LEA     END_LTE_BEG,A1
000010C8  103C 000D                108      MOVE.B  #13,D0
000010CC  4E4F                     109      TRAP    #15
000010CE  6000 0170                110      BRA     END_NOW
000010D2                           111    
000010D2                           112    
000010D2                           113  MAIN_LOOP
000010D2                           114      *BRA     END_NOW
000010D2  BDCD                     115      CMPA.L  A5,A6
000010D4  6C00 016A                116      BGE     END_NOW * End program
000010D8                           117      *MOVE.W  A6,D0   * Copy A6 location to restore after jump to SR
000010D8  4EB9 0000124E            118      JSR     OP_DECODE
000010DE                           119      
000010DE                           120  PRINT_LOOP ;; Print the most recently decoded line
000010DE                           121      * FIRST print a null terminator at (A4) [write loop in EA module does not do this]
000010DE  47F9 00001238            122      LEA     NULL_TERM,A3
000010E4  18D3                     123      MOVE.B  (A3),(A4)+   * This way trap task 13 works
000010E6  103C 000D                124      MOVE.B  #13,D0
000010EA  4E4F                     125      TRAP    #15
000010EC  60E4                     126      BRA     MAIN_LOOP
000010EE                           127      
000010EE                           128  ;; print nops
000010EE                           129  PRINT_NOPS_TEST
000010EE  103C 000F                130      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
000010F2  143C 0010                131      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
000010F6                           132      * PRINT THE CURRENT ADDRESS
000010F6  220E                     133      MOVE.L  A6,D1
000010F8  4E4F                     134      TRAP    #15
000010FA  4281                     135      CLR.L   D1          * clear D1 so that it holds just the data on the next print
000010FC                           136      
000010FC  43F9 00001163            137      LEA     COLON_SPACE,A1
00001102  103C 000E                138      MOVE.B  #14,D0
00001106  4E4F                     139      TRAP    #15
00001108                           140      
00001108  103C 0001                141      MOVE.B  #1,D0   * Print string, no CRLF
0000110C                           142      
0000110C                           143      
0000110C                           144      
0000110C                           145      
0000110C                           146  
0000110C                           147  ;; ~~~~~~~~BEGINNING OF PRINT LOOP~~~~~~~~   
0000110C                           148  PRINT_IT          ;; Placeholder for now; just prints all data between start and end
0000110C  43F9 0000120B            149      LEA     PRINT_IT_STRING,A1
00001112  103C 000D                150      MOVE.B  #13,D0
00001116  4E4F                     151      TRAP    #15
00001118                           152      
00001118                           153  PRINT_IT_LOOP
00001118  103C 000F                154      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
0000111C  143C 0010                155      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
00001120                           156      * PRINT THE CURRENT ADDRESS
00001120  220E                     157      MOVE.L  A6,D1
00001122  4E4F                     158      TRAP    #15
00001124  4281                     159      CLR.L   D1          * clear D1 so that it holds just the data on the next print
00001126                           160      
00001126  43F9 00001163            161      LEA     COLON_SPACE,A1
0000112C  103C 000E                162      MOVE.B  #14,D0
00001130  4E4F                     163      TRAP    #15
00001132                           164      
00001132  221E                     165      MOVE.L  (A6)+,D1    * move the data at the pointer into D1 and increment.
00001134  103C 000F                166      MOVE.B  #15,D0      * Trap task 15 to print a signed number in the base in D2
00001138  4E4F                     167      TRAP    #15
0000113A                           168      
0000113A                           169      * Print a new line
0000113A  43F9 0000115A            170      LEA     NEW_LINE,A1
00001140  103C 000D                171      MOVE.B  #13,D0
00001144  4E4F                     172      TRAP    #15
00001146                           173      
00001146                           174      * Check if end address has been reached
00001146  BDCD                     175      CMP.L   A5,A6
00001148  6FCE                     176      BLE     PRINT_IT_LOOP
0000114A                           177  ;; ~~~~~~~~END OF PRINT LOOP~~~~~~~~
0000114A                           178  
0000114A                           179  
0000114A                           180      
0000114A                           181      
0000114A  43F9 0000115D            182      LEA     DONE_MSG,A1
00001150  103C 000D                183      MOVE.B  #13,D0
00001154  4E4F                     184      TRAP    #15
00001156                           185  
00001156  FFFF FFFF                186      SIMHALT             ; halt simulator
0000115A                           187  
0000115A                           188  * Put variables and constants here
0000115A                           189  
0000115A                           190  *** ASCII constants used in the conversion loop. Subtract these from an ASCII character to get its
0000115A                           191  *** real hex value (depending on whether it's a digit or a character).
0000115A  =00000030                192  ASC_NUM_MIN     EQU     $30     * ASCII key for 0
0000115A  =00000039                193  ASC_NUM_MAX     EQU     $39     * ASCII key for 9
0000115A  =00000041                194  ASC_CHAR_MIN    EQU     $41     * ASCII key for A
0000115A  =00000046                195  ASC_CHAR_MAX    EQU     $46     * ASCII key for F
0000115A                           196  
0000115A                           197  *** Message strings
0000115A                           198      * Temporary; used for debugging and testing
0000115A= 00 0D 0A                 199  NEW_LINE        DC.B    '',0,CR,LF
0000115D                           200      * Temporary; used for debugging and testing
0000115D= 44 6F 6E 65 2E 00        201  DONE_MSG        DC.B    'Done.',0
00001163                           202      * Temporary; used for debugging and testing
00001163= 3A 20 00                 203  COLON_SPACE     DC.B    ': ',0
00001166= 49 6E 76 61 6C 69 ...    204  INVALID_INPUT   DC.B    'Invalid input! Out of Range.',0
00001183= 49 6E 76 61 6C 69 ...    205  END_LTE_BEG     DC.B    'Invalid input! End address is less than or equal to start address.',0  
000011C6= 45 6E 74 65 72 20 ...    206  ADDR_PRMPT_STRT DC.B    'Enter a starting address in hex: $',0
000011E9= 45 6E 74 65 72 20 ...    207  ADDR_PRMPT_END  DC.B    'Enter an ending address in hex: $',0
0000120B= 49 20 61 6D 20 61 ...    208  PRINT_IT_STRING DC.B    'I am a PRINT_IT string. It is printing time!',0
00001238= 00                       209  NULL_TERM       DC.B    '',0
00001239  =0000000A                210  LF              EQU      $0A
00001239  =0000000D                211  CR              EQU      $0D
00001239                           212  
0000123A= 00000001                 213  buffer  DC.L    1
0000123E                           214  
0000123E  =00008000                215  DISM_CODE     EQU     $8000 * Where to write disassembled code
0000123E                           216      
0000123E  4E71                     217      NOP
00001240                           218  
00001240                           219  END_NOW
00001240  43F8 115D                220      LEA     DONE_MSG,A1
00001244  103C 0001                221      MOVE.B  #1,D0
00001248  4E4F                     222      TRAP    #15
0000124A  43F8 123A                223      LEA     buffer,A1
0000124E                           224      
0000124E                           225      INCLUDE 'OP.X68'
0000124E                           226  
0000124E                           227  ;; ~*~*~*~*~*~*~*~BEGIN OPCODE MODULE~*~*~*~*~*~*~*~
0000124E                           228  
0000124E                           229  OP_DECODE
0000124E  3A1E                     230      MOVE.W  (A6)+,D5     * Load the next opcode to decode into D5, incrementing
00001250                           231      * NOTE: A6 now points at either the next opcode or imm. data for EA part
00001250                           232      
00001250                           233      * is it NOP?
00001250  BA7C 4E71                234      CMP.W   #CODE_NOP,D5
00001254  6700 021E                235      BEQ     DO_NOP      * After execution of this branch, will return to I/O
00001258                           236      
00001258                           237      * is it RTS?
00001258  BA7C 4E75                238      CMP.W   #CODE_RTS,D5
0000125C  6700 0228                239      BEQ     DO_RTS      * After execution of this branch, will return to I/O
00001260                           240      
00001260                           241      ** Not NOP or RTS, check bit-by-bit to narrow down
00001260                           242      
00001260  0805 000F                243      BTST.L  #15,D5       * Test the most significant bit of the command
00001264  6700 000C                244      BEQ     OXXX_BRA     * Branch to opcodes starting with zero     
00001268  6000 00FA                245      BRA     IXXX_BRA     * Branch to opcodes starting with a one  ******** COME BAK
0000126C                           246     
0000126C  6000 0206                247      BRA     DO_NOP
00001270  4E75                     248      RTS * Return to I/O module (temporary; will go to EA module eventually)
00001272                           249      
00001272                           250  OXXX_BRA
00001272  0805 000E                251      BTST.L  #14,D5      * Test the second bit 
00001276  6700 0006                252      BEQ     OOXX_BRA    * Branch to opcodes starting with 00
0000127A  6000 0012                253      BRA     OIXX_BRA    * Branch to opcodes starting with 01   *** COME BAK
0000127E                           254  
0000127E                           255  OOXX_BRA
0000127E  0805 000D                256      BTST.L  #13,D5          * Test the second bit 
00001282  6700 0016                257      BEQ     OOOX_BRA        * Branch to opcodes starting with 000
00001286  6000 001E                258      BRA     OOIX_BRA        * Might be MOVE, MOVEA
0000128A  6000 0242                259      BRA     PRINT_INVALID_MSG
0000128E                           260  OIXX_BRA
0000128E  0805 000D                261      BTST.L  #13,D5
00001292  6700 008A                262      BEQ     OIOX_BRA            * CLR, JSR, MOVEM, LEA, ADDQ, SUBQ
00001296  6000 0092                263      BRA     OIIX_BRA            * BCC, OR MOVEQ
0000129A                           264  OOOX_BRA
0000129A  0805 000C                265      BTST.L  #12,D5              * Test the second bit 
0000129E  6700 0012                266      BEQ     OOOO_BRA            * Decision for SUBI or ADDI
000012A2  6000 0028                267      BRA     OOOI_BRA            * MOVE and MOVEA (B)
000012A6                           268  OOIX_BRA
000012A6  0805 000C                269      BTST.L  #12,D5              * Test the second bit 
000012AA  6700 0032                270      BEQ     OOIO_BRA            * MOVE or MOVEA need to be handled here (W)
000012AE  6000 004E                271      BRA     OOII_BRA            * MOVE or MOVEA need to be handled here (L)
000012B2                           272  
000012B2                           273  OOOO_BRA                        * tests for ADDI or SUBI
000012B2  343C 0F00                274      MOVE.W  #ADDSUBI_MASK,D2   * Load mask for ADDI temporarily into register for AND operation
000012B6  C445                     275      AND.W   D5,D2               * AND with current opcode data and store into D2
000012B8  B47C 0600                276      CMP.W   #$0600,D2           * Result of mask should be 0060 if the code is ADDi
000012BC  6700 0126                277      BEQ     DO_ADDI     
000012C0  B47C 0400                278      CMP.W   #$0400,D2           * SUBI and ADDI  have the same bitmask.
000012C4  6700 0166                279      BEQ     DO_SUBI
000012C8  6000 0204                280      BRA     PRINT_INVALID_MSG
000012CC                           281  OOOI_BRA                        * MOVE and MOVEA need to be handled here (B)
000012CC  343C 3000                282      MOVE.W  #MOVE_MASK,D2
000012D0  C445                     283      AND.W   D5,D2
000012D2  B47C 1000                284      CMP.W   #$1000,D2           * is it a move byte?
000012D6  6700 0090                285      BEQ     DO_MOVE_B           
000012DA                           286  
000012DA  6000 01F2                287      BRA     PRINT_INVALID_MSG   *neither MoveA or Move? BADDDD
000012DE                           288  OOIO_BRA                        * MOVE and MOVEA need to be handled here (W)
000012DE  343C 31C0                289      MOVE.W  #MOVEA_MASK,D2
000012E2  C445                     290      AND.W   D5,D2
000012E4  B47C 2040                291      CMP.W   #$2040,D2           * is it a moveA word?
000012E8  6700 0090                292      BEQ     DO_MOVEA_W          
000012EC                           293  
000012EC  343C 3000                294      MOVE.W  #MOVE_MASK,D2
000012F0  C445                     295      AND.W   D5,D2
000012F2  B47C 2000                296      CMP.W   #$2000,D2           * is it a move word?
000012F6  6700 0094                297      BEQ     DO_MOVE_W           
000012FA                           298  
000012FA  6000 01D2                299      BRA     PRINT_INVALID_MSG
000012FE                           300  OOII_BRA                        * MOVE and MOVEA need to be handled here (L)
000012FE  343C 31C0                301      MOVE.W  #MOVEA_MASK,D2
00001302  C445                     302      AND.W   D5,D2
00001304  B47C 3040                303      CMP.W   #$3040,D2           * is it a moveA long?
00001308  6700 0094                304      BEQ     DO_MOVEA_L          
0000130C                           305  
0000130C  343C 3000                306      MOVE.W  #MOVE_MASK,D2
00001310  C445                     307      AND.W   D5,D2
00001312  B47C 3000                308      CMP.W   #$3000,D2           * is it a move long?
00001316  6700 0098                309      BEQ     DO_MOVE_L           
0000131A                           310  
0000131A  6000 01B2                311      BRA     PRINT_INVALID_MSG
0000131E                           312  OIOX_BRA
0000131E  0805 000C                313      BTST.L  #12,D5
00001322  6700 0012                314      BEQ     OIOO_BRA    * CLR, JSR, MOVEM, LEA   
00001326  6000 0116                315      BRA     DO_ADDQ     * ADDQ 
0000132A                           316  OIIX_BRA
0000132A                           317      *check for MOVEQ and BCC here, which is 0110 always. there is no 0111
0000132A  0805 000C                318      BTST.L  #12,D5
0000132E  6700 00EA                319      BEQ     DO_Bcc            * BCC happens here, have to narrow it down to which one!
00001332  6000 0176                320      BRA     DO_MOVEQ   
00001336                           321  OIOO_BRA
00001336                           322      ** Test for JSR
00001336  343C 0FC0                323      MOVE.W  #JSR_MASK,D2 * Load mask temporarily into register for ANDing
0000133A  C445                     324      AND.W   D5,D2        * AND with the current opcode data
0000133C  B47C 0E80                325      CMP.W   #$0E80,D2    * Result of mask should be 0E80 if code is JSR
00001340  6700 017A                326      BEQ     DO_JSR       *
00001344                           327  
00001344  343C 0F00                328      MOVE.W  #CLR_MASK,D2
00001348  C445                     329      AND.W   D5,D2
0000134A  B47C 0200                330      CMP.W   #$0200,D2              * IS IT CLR?
0000134E  6700 0100                331      BEQ     DO_CLR
00001352                           332  
00001352  343C 01C0                333      MOVE.W  #LEA_MASK,D2
00001356  C445                     334      AND     D5,D2
00001358  B47C 01C0                335      CMP.W   #$01C0,D2              *EQUAL TO LEA?
0000135C  6700 0104                336      BEQ.W   DO_LEA
00001360  6000 017E                337      BRA     PRINT_OIOO_ERROR       * if not RTS, not JSR, CLR, or LEA, then its invalid. 
00001364                           338  
00001364                           339  IXXX_BRA
00001364  6000 018C                340      BRA     PRINT_COME_BACK_MSG   * temporary until further development of right branch
00001368                           341      
00001368                           342  DO_MOVE_B
00001368  47F9 000015D4            343      LEA     S_MOVE_B,A3
0000136E  1E3C 002A                344      MOVE.B  #$2A,D7         * for now, temporarily calling this mnemonic number 2, section a (which is a byte)
00001372                           345      ** Eventually, EA Module will be called here
00001372  4EB9 00001504            346      JSR     WRITE
00001378  4E75                     347      RTS
0000137A                           348  DO_MOVEA_W
0000137A  47F9 000015E4            349      LEA     S_MOVEA_W,A3
00001380  1E3C 003B                350      MOVE.B  #$3B,D7         * for now, temporarily calling this mnemonic number 3, section b (which is a word)
00001384                           351      ** Eventually, EA Module will be called here
00001384  4EB9 00001504            352      JSR     WRITE
0000138A  4E75                     353      RTS
0000138C                           354  DO_MOVE_W
0000138C  47F9 000015F4            355      LEA     S_MOVE_W,A3
00001392  1E3C 002B                356      MOVE.B  #$2B,D7         * for now, temporarily calling this mnemonic number 2, section b (which is a word)
00001396                           357      ** Eventually, EA Module will be called here
00001396  4EB9 00001504            358      JSR     WRITE
0000139C  4E75                     359      RTS
0000139E                           360  DO_MOVEA_L
0000139E  47F9 00001604            361      LEA     S_MOVEA_L,A3
000013A4  1E3C 003C                362      MOVE.B  #$3C,D7         * for now, temporarily calling this mnemonic number 3, section c (which is a long)
000013A8                           363      ** Eventually, EA Module will be called here
000013A8  4EB9 00001504            364      JSR     WRITE
000013AE  4E75                     365      RTS
000013B0                           366  DO_MOVE_L
000013B0  47F9 00001614            367      LEA     S_MOVE_L,A3
000013B6  1E3C 002C                368      MOVE.B  #$2C,D7         * for now, temporarily calling this mnemonic number 2, section c (which is a long)
000013BA                           369      ** Eventually, EA Module will be called here
000013BA  4EB9 00001504            370      JSR     WRITE
000013C0  4E75                     371      RTS
000013C2                           372  
000013C2                           373  DO_BCC_CASE
000013C2  343C 0F00                374      MOVE.W  #Bcc_MASK,D2
000013C6  C445                     375      AND     D5,D2
000013C8  B47C 0E00                376      CMP.W   #$0E00,D2                * Is it BGT?
000013CC  6700 0028                377      BEQ.W   DO_BGT
000013D0                           378      
000013D0  B47C 0F00                379      CMP.W   #$0F00,D2                * Is it BLE?
000013D4  6700 0032                380      BEQ.W   DO_BLE
000013D8                           381  
000013D8  B47C 0400                382      CMP.W   #$0400,D2                * Is it BCC?
000013DC  6700 003C                383      BEQ.W   DO_BCC
000013E0                           384  
000013E0  6000 00EC                385      BRA     PRINT_INVALID_MSG        * none of these options? not required or invalid
000013E4                           386  
000013E4                           387  DO_ADDI
000013E4  47F9 00001554            388      LEA     S_ADDI,A3
000013EA  1E3C 0008                389      MOVE.B  #8,D7
000013EE                           390      ** Eventually, EA Module will be called here
000013EE  4EB9 00001504            391      JSR     WRITE
000013F4  4E75                     392      RTS
000013F6                           393  DO_BGT
000013F6  47F9 000015A4            394      LEA     S_BGT,A3
000013FC  1E3C 001A                395      MOVE.B  #26,D7
00001400                           396      ** Eventually, EA Module will be called here
00001400  4EB9 00001504            397      JSR     WRITE
00001406  4E75                     398      RTS
00001408                           399  DO_BLE
00001408  47F9 000015B4            400      LEA     S_BLE,A3
0000140E  1E3C 001B                401      MOVE.B  #27,D7
00001412                           402      ** Eventually, EA Module will be called here
00001412  4EB9 00001504            403      JSR     WRITE
00001418  4E75                     404      RTS
0000141A                           405  DO_BCC
0000141A  47F9 000015C4            406      LEA     S_BCC,A3
00001420  1E3C 001C                407      MOVE.B  #28,D7
00001424                           408      ** Eventually, EA Module will be called here
00001424  4EB9 00001504            409      JSR     WRITE
0000142A  4E75                     410      RTS
0000142C                           411  DO_SUBI
0000142C  47F9 00001564            412      LEA     S_SUBI,A3
00001432  1E3C 000B                413      MOVE.B  #11,D7
00001436                           414      ** Eventually, EA Module will be called here
00001436  4EB9 00001504            415      JSR     WRITE
0000143C  4E75                     416      RTS
0000143E                           417  DO_ADDQ
0000143E                           418      *Check for full opcode for 11 and onwards. if invalid, print the message
0000143E  47F9 00001544            419      LEA     S_ADDQ,A3
00001444  1E3C 0009                420      MOVE.B  #9,D7
00001448                           421      ** Eventually, EA Module will be called here
00001448  4EB9 00001504            422      JSR     WRITE
0000144E  4E75                     423      RTS
00001450                           424  DO_CLR
00001450  47F9 00001574            425      LEA     S_CLR,A3
00001456  1E3C 0010                426      MOVE.B  #16,D7
0000145A                           427      ** Eventually, EA Module will be called here
0000145A  4EB9 00001504            428      JSR     WRITE
00001460  4E75                     429      RTS
00001462                           430  DO_LEA
00001462  47F9 00001584            431      LEA     S_LEA,A3    * Load the NOP string into A3 for WRITE subroutine
00001468  1E3C 000F                432      MOVE.B  #15,D7       * Store key for op code for EA module
0000146C                           433      ** Eventually, EA Module will be called here
0000146C  4EB9 00001504            434      JSR     WRITE       * Jump to WRITE subroutine
00001472  4E75                     435      RTS                 * Return to I/O module 
00001474                           436  DO_NOP
00001474  47F9 00001510            437      LEA     S_NOP,A3    * Load the NOP string into A3 for WRITE subroutine
0000147A  1E3C 0001                438      MOVE.B  #1,D7       * Store key for op code for EA module
0000147E                           439      ** Eventually, EA Module will be called here
0000147E  4EB9 00001504            440      JSR     WRITE       * Jump to WRITE subroutine
00001484  4E75                     441      RTS                 * Return to I/O module 
00001486                           442  DO_RTS
00001486  47F9 00001520            443      LEA     S_RTS,A3    * Load the RTS string into A3 for WRITE subroutine
0000148C  1E3C 001E                444      MOVE.B  #30,D7      * Store key for op code for EA module
00001490                           445      ** Eventually, EA Module will be called here
00001490  4EB9 00001504            446      JSR     WRITE       * Jump to WRITE subroutine
00001496  4E75                     447      RTS                 * Return to the I/O module bra op_decode  
00001498                           448  DO_MOVE
00001498  47F9 00001530            449      LEA     S_MOVE,A3
0000149E  1E3C 0002                450      MOVE.B  #2,D7
000014A2                           451      ** Eventually, EA Module will be called here
000014A2  4EB9 00001504            452      JSR     WRITE
000014A8  4E75                     453      RTS
000014AA                           454  DO_MOVEQ
000014AA  47F9 00001594            455      LEA     S_MOVEQ,A3
000014B0  1E3C 0004                456      MOVE.B  #4,D7
000014B4  4EB9 00001504            457      JSR     WRITE
000014BA  4E75                     458      RTS
000014BC                           459  DO_JSR
000014BC  47F9 00001540            460      LEA     S_JSR,A3
000014C2  1E3C 001B                461      MOVE.B  #27,D7
000014C6                           462      ** Eventually, NOCK will be called here
000014C6  4EB9 00001504            463      JSR     WRITE
000014CC  4E75                     464      RTS
000014CE                           465  PRINT_INVALID_MSG
000014CE  47F9 00001624            466      LEA     INVALID,A3
000014D4  1E3C 0000                467      MOVE.B  #0,D7
000014D8                           468      ** Eventually, NOCK will be called here
000014D8  4EB9 00001504            469      JSR     WRITE
000014DE  4E75                     470      RTS
000014E0                           471  PRINT_OIOO_ERROR
000014E0  47F9 00001673            472      LEA     BAD_OIOO,A3
000014E6  1E3C 0000                473      MOVE.B  #0,D7
000014EA                           474      ** Eventually, NOCK will be called here
000014EA  4EB9 00001504            475      JSR     WRITE
000014F0  4E75                     476      RTS
000014F2                           477  PRINT_COME_BACK_MSG
000014F2  47F9 00001650            478      LEA     COMEBK,A3
000014F8  1E3C 0000                479      MOVE.B  #0,D7
000014FC                           480      ** Eventually, NOCK will be called here
000014FC  4EB9 00001504            481      JSR     WRITE
00001502  4E75                     482      RTS
00001504                           483  WRITE   * Writes string pointed to by A3 to memory pointed to by A1
00001504  224C                     484      MOVEA.L A4,A1     * Save the position of A4 before writing (for I/0)
00001506                           485  WRITE_LOOP
00001506  18DB                     486      MOVE.B  (A3)+,(A4)+     * Write one byte and increment
00001508  0C13 0000                487      CMP.B   #0,(A3)         * Are we at the null terminator?
0000150C  66F8                     488      BNE     WRITE_LOOP      * If not, keep going
0000150E                           489      **MOVE.B  (A3)+,(A4)+     * Write the null terminator before exiting
0000150E  4E75                     490      RTS                     * Executes once null terminator was reached
00001510                           491      
00001510                           492  ;; ~~~~~~~~STRING CONSTANTS~~~~~~~~
00001510                           493  
00001510  =00004E71                494  CODE_NOP    EQU     $4E71
00001510  =00004E75                495  CODE_RTS    EQU     $4E75
00001510                           496  
00001510  =00002000                497  A4_PREV     SET     $2000
00001510                           498  
00001510= 4E 4F 50 20 20 20 ...    499  S_NOP       DC.B    'NOP            ',0
00001520= 52 54 53 20 20 20 ...    500  S_RTS       DC.B    'RTS            ',0
00001530= 4D 4F 56 45 20 20 ...    501  S_MOVE      DC.B    'MOVE           ',0
00001540= 4A 53 52 00              502  S_JSR       DC.B    'JSR',0
00001544= 41 44 44 51 20 20 ...    503  S_ADDQ      DC.B    'ADDQ           ',0
00001554= 41 44 44 49 20 20 ...    504  S_ADDI      DC.B    'ADDI           ',0
00001564= 53 55 42 49 20 20 ...    505  S_SUBI      DC.B    'SUBI           ',0
00001574= 43 4C 52 20 20 20 ...    506  S_CLR       DC.B    'CLR            ',0
00001584= 4C 45 41 20 20 20 ...    507  S_LEA       DC.B    'LEA            ',0    
00001594= 4D 4F 56 45 51 20 ...    508  S_MOVEQ     DC.B    'MOVEQ          ',0
000015A4= 42 47 54 20 20 20 ...    509  S_BGT       DC.B    'BGT            ',0
000015B4= 42 4C 45 20 20 20 ...    510  S_BLE       DC.B    'BLE            ',0
000015C4= 42 43 43 20 20 20 ...    511  S_BCC       DC.B    'BCC            ',0
000015D4= 4D 4F 56 45 2E 42 ...    512  S_MOVE_B    DC.B    'MOVE.B         ',0
000015E4= 4D 4F 56 45 41 2E ...    513  S_MOVEA_W   DC.B    'MOVEA.W        ',0
000015F4= 4D 4F 56 45 2E 57 ...    514  S_MOVE_W    DC.B    'MOVE.W         ',0
00001604= 4D 4F 56 45 41 2E ...    515  S_MOVEA_L   DC.B    'MOVEA.L        ',0
00001614= 4D 4F 56 45 2E 4C ...    516  S_MOVE_L    DC.B    'MOVE.L         ',0
00001624                           517  
00001624                           518  
00001624= 49 4E 56 41 4C 49 ...    519  INVALID     DC.B    'INVALID OPCODE. LETS FIX THIS MESSAGE LATER',0
00001650= 43 6F 6D 65 20 62 ...    520  COMEBK      DC.B    'Come back to me pls dont forget me',0 
00001673= 42 61 64 20 4F 49 ...    521  BAD_OIOO    DC.B    'Bad OIOO maybe not JSR,RTS,CLR,LEA.. who knows.',0
000016A3                           522  
000016A3  =00000FC0                523  JSR_MASK        EQU     %0000111111000000
000016A3  =00000F00                524  ADDSUBI_MASK    EQU     %0000111100000000       ** come back and fix this to be the same but diferent comparisons 
000016A3  =00000000                525  BYTE_MASK       EQU     %0000000000000000       * Not sure if this is needed
000016A3  =00000040                526  WORD_MASK       EQU     %0000000001000000       * not sure if this is needed
000016A3  =00000080                527  LONG_MASK       EQU     %0000000010000000       * not sure if this is needed
000016A3  =00000F00                528  CLR_MASK        EQU     %0000111100000000
000016A3  =000001C0                529  LEA_MASK        EQU     %0000000111000000
000016A3  =00000F00                530  Bcc_MASK        EQU     %0000111100000000
000016A3                           531  
000016A3  =000031C0                532  MOVEA_MASK      EQU     %0011000111000000
000016A3  =00003000                533  MOVE_MASK       EQU     %0011000000000000
000016A3                           534  ;; ~*~*~*~*~*~*~*~END OPCODE MODULE~*~*~*~*~*~*~*~
000016A3                           535  
000016A3                           536  
000016A3                           537  
000016A3                           538  -------------------- end include --------------------
000016A3                           539      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A4_PREV             2000
ADDR_PRMPT_END      11E9
ADDR_PRMPT_STRT     11C6
ADDSUBI_MASK        F00
ASC_CHAR_MAX        46
ASC_CHAR_MIN        41
ASC_NUM_MAX         39
ASC_NUM_MIN         30
ASC_TO_CHAR         109C
ASC_TO_NUM          1092
BAD_OIOO            1673
BCC_MASK            F00
BUFFER              123A
BYTE_MASK           0
CHECK_CHAR_MAX      1086
CHECK_CHAR_MIN      107A
CHECK_NUM_MAX       106C
CHECK_NUM_MIN       1060
CLR_MASK            F00
CODE_NOP            4E71
CODE_RTS            4E75
COLON_SPACE         1163
COMEBK              1650
CONVERSION_LOOP     105E
CR                  D
DISM_CODE           8000
DONE_MSG            115D
DO_ADDI             13E4
DO_ADDQ             143E
DO_BCC              141A
DO_BCC_CASE         13C2
DO_BGT              13F6
DO_BLE              1408
DO_CLR              1450
DO_JSR              14BC
DO_LEA              1462
DO_MOVE             1498
DO_MOVEA_L          139E
DO_MOVEA_W          137A
DO_MOVEQ            14AA
DO_MOVE_B           1368
DO_MOVE_L           13B0
DO_MOVE_W           138C
DO_NOP              1474
DO_RTS              1486
DO_SUBI             142C
END_LTE_BEG         1183
END_NOW             1240
ERROR_END_LTE_BEG   10C2
ERROR_INV_INP       10B2
INVALID             1624
INVALID_INPUT       1166
IXXX_BRA            1364
JSR_MASK            FC0
LEA_MASK            1C0
LF                  A
LONG_MASK           80
MAIN_LOOP           10D2
MOVEA_MASK          31C0
MOVE_MASK           3000
NEW_LINE            115A
NULL_TERM           1238
OIIX_BRA            132A
OIOO_BRA            1336
OIOX_BRA            131E
OIXX_BRA            128E
OOII_BRA            12FE
OOIO_BRA            12DE
OOIX_BRA            12A6
OOOI_BRA            12CC
OOOO_BRA            12B2
OOOX_BRA            129A
OOXX_BRA            127E
OP_DECODE           124E
OXXX_BRA            1272
PRINT_COME_BACK_MSG  14F2
PRINT_INVALID_MSG   14CE
PRINT_IT            110C
PRINT_IT_LOOP       1118
PRINT_IT_STRING     120B
PRINT_LOOP          10DE
PRINT_NOPS_TEST     10EE
PRINT_OIOO_ERROR    14E0
SHIFTS              10A6
START               1000
S_ADDI              1554
S_ADDQ              1544
S_BCC               15C4
S_BGT               15A4
S_BLE               15B4
S_CLR               1574
S_JSR               1540
S_LEA               1584
S_MOVE              1530
S_MOVEA_L           1604
S_MOVEA_W           15E4
S_MOVEQ             1594
S_MOVE_B            15D4
S_MOVE_L            1614
S_MOVE_W            15F4
S_NOP               1510
S_RTS               1520
S_SUBI              1564
WORD_MASK           40
WRITE               1504
WRITE_LOOP          1506
