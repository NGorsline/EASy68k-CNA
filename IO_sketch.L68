00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/27/2018 4:57:29 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler I/O 
00000000                             3  * Written by :  touCANs
00000000                             4  * Date       :  5/1/18 - 
00000000                             5  * Description:  I/O functionality for the disassembler 
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000                            12      ; A4 will point at where we write disassembled code (use to write ASCII)
00001000  287C 00008000             13      MOVEA.L #DISM_CODE,A4
00001006                            14      
00001006                            15      ; Print the input prompt message and get input as a string from user
00001006  43F9 0000115F             16      LEA     ADDR_PRMPT_STRT,A1
0000100C  103C 000E                 17      MOVE.B  #14,D0
00001010  4E4F                      18      TRAP    #15
00001012  103C 0002                 19      MOVE.B  #2,D0           * get starting address from the user as a string
00001016  4E4F                      20      TRAP    #15         
00001018                            21      
00001018                            22      ; Check if D1 is valid size, minimum 4 (user entered at least 4 hexa bits)
00001018  B27C 0004                 23      CMP     #4,D1           * minimum of a word for the address
0000101C  6D00 008E                 24      BLT     ERROR_INV_INP   * branch to print the invalid input error msg
00001020  4EB9 00001058             25      JSR     CONVERSION_LOOP * convert the starting address from ASCII to hex
00001026                            26  
00001026                            27      ; Starting address has been converted; store it in A6 and get end address
00001026  2C42                      28      MOVEA.L D2,A6           * A6 acts as iterator while disassembling
00001028  4282                      29      CLR.L   D2              * prepare D2 to hold converted end address
0000102A  4284                      30      CLR.L   D4              * clear D4 to start the counter at 0 again
0000102C  43F9 00001182             31      LEA     ADDR_PRMPT_END,A1
00001032  103C 000E                 32      MOVE.B  #14,D0          * prompt user to enter end address
00001036  4E4F                      33      TRAP    #15
00001038                            34      
00001038  103C 0002                 35      MOVE.B  #2,D0           * get end address from user as a string
0000103C  4E4F                      36      TRAP    #15
0000103E                            37      
0000103E                            38      ; Check if D1 is valid size, minimum 4 (user entered at least 4 hexa bits)
0000103E  B27C 0004                 39      CMP     #4,D1           * minimum of a word for the address
00001042  6D00 0068                 40      BLT     ERROR_INV_INP   * branch to print the invalid input error msg
00001046  4EB9 00001058             41      JSR     CONVERSION_LOOP * convert the ending address
0000104C                            42      
0000104C                            43      ; Ending address has been converted; store it in A5
0000104C  2A42                      44      MOVEA.L D2,A5           * compare A6 to A5 to know when to stop
0000104E  BDCD                      45      CMPA.L  A5,A6           * check beginning address >= end address
00001050  6C00 006A                 46      BGE     ERROR_END_LTE_BEG
00001054  6000 0076                 47      BRA     MAIN_LOOP       * if all error checks pass, start main loop
00001058                            48      
00001058                            49  
00001058                            50  
00001058                            51  
00001058                            52  
00001058                            53  ;; ~~~~~~~~BEGINNING OF CONVERSION SUBROUTINE~~~~~~~~
00001058                            54  CONVERSION_LOOP       
00001058  1619                      55      MOVE.B  (A1)+,D3        * Store the next byte to convert in D3
0000105A                            56  
0000105A                            57  CHECK_NUM_MIN     ;; Checks if number is >= 30 (0) in ASCII
0000105A  B67C 0030                 58      CMP     #ASC_NUM_MIN,D3 * Range of ASCII numbers: [2F,3A] then subtract 30
0000105E  6C00 0006                 59      BGE     CHECK_NUM_MAX   * check if it's in range for x > 2F
00001062  6000 0048                 60      BRA     ERROR_INV_INP   * First condition not met, go to bad input error 
00001066                            61      
00001066                            62  CHECK_NUM_MAX     ;; Checks if number is <= 39 (9) in ASCII
00001066  B67C 0039                 63      CMP     #ASC_NUM_MAX,D3
0000106A  6F00 0020                 64      BLE     ASC_TO_NUM      * If condition for the range was met, do the math
0000106E  4EF9 00001074             65      JMP     CHECK_CHAR_MIN  * Second condition not met, check if a character
00001074                            66      
00001074                            67  CHECK_CHAR_MIN    ;; Checks if number is >= 41 (A) in ASCII
00001074  B67C 0041                 68      CMP     #ASC_CHAR_MIN,D3
00001078  6C00 0006                 69      BGE     CHECK_CHAR_MAX  
0000107C  6000 002E                 70      BRA     ERROR_INV_INP   * First condition not met, go to bad input error
00001080                            71      
00001080                            72  CHECK_CHAR_MAX    ;; Checks if number is <= 46 (F) in ASCII
00001080  B67C 0046                 73      CMP     #ASC_CHAR_MAX,D3
00001084  6F00 0010                 74      BLE     ASC_TO_CHAR     * Condition was met for A-F
00001088  6000 0022                 75      BRA     ERROR_INV_INP   * Greater than 46 = out of 16-bit system
0000108C                            76      
0000108C                            77  ASC_TO_NUM        ;; Converts a string digit into a hex value
0000108C  0403 0030                 78      SUBI.B  #$30,D3
00001090  4EF9 000010A0             79      JMP     SHIFTS          * After routine is finished, complete shifts/adds
00001096                            80      
00001096                            81  ASC_TO_CHAR       ;; Converts a string character into a hex value
00001096  0403 0037                 82      SUBI.B  #$37,D3    
0000109A  4EF9 000010A0             83      JMP     SHIFTS
000010A0                            84      
000010A0                            85  SHIFTS            ;; Shifts D2 left to make room for converted hexabit
000010A0  E98A                      86      LSL.L   #4,D2           * shift hexabit left to make room
000010A2  D403                      87      ADD.B   D3,D2           * Add modified value from D3 into D2.
000010A4                            88      
000010A4  5204                      89      ADD.B   #1,D4           * Increment counter by 1
000010A6  B244                      90      CMP     D4,D1           * Check if end of input reached (D4 = counter)
000010A8  66AE                      91      BNE     CONVERSION_LOOP * Continue back to the loop if D4 != D1  
000010AA  4E75                      92      RTS
000010AC                            93  ;; ~~~~~~~~END OF CONVERSION SUBROUTINE~~~~~~~~
000010AC                            94  
000010AC                            95  
000010AC                            96  
000010AC                            97  ERROR_INV_INP ;; Prints the INVALID_INPUT error message to the console
000010AC  43F9 000010FF             98      LEA     INVALID_INPUT,A1
000010B2  103C 000D                 99      MOVE.B  #13,D0
000010B6  4E4F                     100      TRAP    #15
000010B8  6000 011A                101      BRA     END_NOW
000010BC                           102      
000010BC                           103  ERROR_END_LTE_BEG ;; Prints END_LTE_BEG (end <= beginning) error to console.
000010BC  43F9 0000111C            104      LEA     END_LTE_BEG,A1
000010C2  103C 000D                105      MOVE.B  #13,D0
000010C6  4E4F                     106      TRAP    #15
000010C8  6000 010A                107      BRA     END_NOW
000010CC                           108    
000010CC                           109    
000010CC                           110    
000010CC                           111  ; Main loop of the program; Checks if the iterator (A6) is past the ending 
000010CC                           112  ; address (A5). If not, calls the OP module. Once the OP and EA modules have
000010CC                           113  ; finished, they return to this module, which then places a null terminator
000010CC                           114  ; on the buffer. This is necessary because OP and EA modules do not write a 
000010CC                           115  ; null terminator to the buffer, but trap task 13 needs one to know when to
000010CC                           116  ; stop printing. After the line is printed, A4 is copied into A1 to start 
000010CC                           117  ; printing from the next spot in memory where the buffer (A4) writes to.
000010CC                           118  MAIN_LOOP
000010CC  BDCD                     119      CMPA.L  A5,A6
000010CE  6C00 0104                120      BGE     END_NOW     * End program if iterator is at or past A5 (end addr)
000010D2  4EB9 000011DE            121      JSR     OP_DECODE   * Call the OP module, which will read next word
000010D8  18FC 0000                122      MOVE.B  #$00,(A4)+  * Write null term at end of freshly decoded line
000010DC  103C 000D                123      MOVE.B  #13,D0      * Trap task 13 prints bytes at A1 until a null term
000010E0  4E4F                     124      TRAP    #15
000010E2  224C                     125      MOVEA.L A4,A1       * Set A1 to point at beginning of next decoded line
000010E4                           126      ;;; NICK -- I think you could put logic for printing 10 at a time here.
000010E4  60E6                     127      BRA     MAIN_LOOP
000010E6                           128      
000010E6                           129      * Once the loop exits, print a farewell message to the console.
000010E6  43F9 000010F9            130      LEA     DONE_MSG,A1
000010EC  103C 000D                131      MOVE.B  #13,D0
000010F0  4E4F                     132      TRAP    #15
000010F2                           133  
000010F2  FFFF FFFF                134      SIMHALT             ; halt simulator
000010F6                           135  
000010F6                           136  
000010F6                           137  * Put variables and constants here
000010F6                           138  
000010F6                           139  ; ASCII constants used in the conversion loop. Subtract these from an ASCII
000010F6                           140  ; character to get the raw hex value (depending on whether digit or a char).
000010F6  =00000030                141  ASC_NUM_MIN     EQU     $30     * ASCII key for 0
000010F6  =00000039                142  ASC_NUM_MAX     EQU     $39     * ASCII key for 9
000010F6  =00000041                143  ASC_CHAR_MIN    EQU     $41     * ASCII key for A
000010F6  =00000046                144  ASC_CHAR_MAX    EQU     $46     * ASCII key for F
000010F6                           145  
000010F6                           146  ; Message strings
000010F6= 00 0D 0A                 147  NEW_LINE        DC.B    '',0,CR,LF
000010F9= 44 6F 6E 65 2E 00        148  DONE_MSG        DC.B    'Done.',0
000010FF= 49 6E 76 61 6C 69 ...    149  INVALID_INPUT   DC.B    'Invalid input! Out of Range.',0
0000111C= 49 6E 76 61 6C 69 ...    150  END_LTE_BEG     DC.B    'Invalid input! End address is less than or equal to start address.',0  
0000115F= 45 6E 74 65 72 20 ...    151  ADDR_PRMPT_STRT DC.B    'Enter a starting address in hex: $',0
00001182= 45 6E 74 65 72 20 ...    152  ADDR_PRMPT_END  DC.B    'Enter an ending address in hex: $',0
000011A4= 49 20 61 6D 20 61 ...    153  PRINT_IT_STRING DC.B    'I am a PRINT_IT string. It is printing time!',0
000011D1  =0000000A                154  LF              EQU      $0A
000011D1  =0000000D                155  CR              EQU      $0D
000011D1                           156  
000011D1  =00008000                157  DISM_CODE     EQU     $8000     * Where to write disassembled code
000011D1                           158      
000011D2  4E71                     159      NOP                         * Ensures included files align on word boundary
000011D4                           160  
000011D4                           161  END_NOW
000011D4  43F8 10F9                162      LEA     DONE_MSG,A1
000011D8  103C 0001                163      MOVE.B  #1,D0
000011DC  4E4F                     164      TRAP    #15
000011DE                           165      
000011DE                           166  
000011DE                           167      
000011DE                           168      INCLUDE 'OP.X68'
000011DE                           169  
000011DE                           170  ;; ~*~*~*~*~*~*~*~BEGIN OPCODE MODULE~*~*~*~*~*~*~*~
000011DE                           171  
000011DE                           172  OP_DECODE
000011DE  3A1E                     173      MOVE.W  (A6)+,D5     * Load the next opcode to decode into D5, incrementing
000011E0                           174      * NOTE: A6 now points at either the next opcode or imm. data for EA part
000011E0                           175      
000011E0                           176      * is it NOP?
000011E0  BA7C 4E71                177      CMP.W   #CODE_NOP,D5
000011E4  6700 0230                178      BEQ     DO_NOP      * After execution of this branch, will return to I/O
000011E8                           179      
000011E8                           180      * is it RTS?
000011E8  BA7C 4E75                181      CMP.W   #CODE_RTS,D5
000011EC  6700 023A                182      BEQ     DO_RTS      * After execution of this branch, will return to I/O
000011F0                           183      
000011F0                           184      ** Not NOP or RTS, check bit-by-bit to narrow down
000011F0                           185      
000011F0  0805 000F                186      BTST.L  #15,D5       * Test the most significant bit of the command
000011F4  6700 000C                187      BEQ     OXXX_BRA     * Branch to opcodes starting with zero     
000011F8  6000 00FA                188      BRA     IXXX_BRA     * Branch to opcodes starting with a one  ******** COME BAK
000011FC                           189     
000011FC  6000 0218                190      BRA     DO_NOP
00001200  4E75                     191      RTS * Return to I/O module (temporary; will go to EA module eventually)
00001202                           192      
00001202                           193  OXXX_BRA
00001202  0805 000E                194      BTST.L  #14,D5      * Test the second bit 
00001206  6700 0006                195      BEQ     OOXX_BRA    * Branch to opcodes starting with 00
0000120A  6000 0012                196      BRA     OIXX_BRA    * Branch to opcodes starting with 01   *** COME BAK
0000120E                           197  
0000120E                           198  OOXX_BRA
0000120E  0805 000D                199      BTST.L  #13,D5          * Test the second bit 
00001212  6700 0016                200      BEQ     OOOX_BRA        * Branch to opcodes starting with 000
00001216  6000 001E                201      BRA     OOIX_BRA        * Might be MOVE, MOVEA
0000121A  6000 0254                202      BRA     PRINT_INVALID_MSG
0000121E                           203  OIXX_BRA
0000121E  0805 000D                204      BTST.L  #13,D5
00001222  6700 008A                205      BEQ     OIOX_BRA            * CLR, JSR, MOVEM, LEA, ADDQ, SUBQ
00001226  6000 0092                206      BRA     OIIX_BRA            * BCC, OR MOVEQ
0000122A                           207  OOOX_BRA
0000122A  0805 000C                208      BTST.L  #12,D5              * Test the second bit 
0000122E  6700 0012                209      BEQ     OOOO_BRA            * Decision for SUBI or ADDI
00001232  6000 0028                210      BRA     OOOI_BRA            * MOVE and MOVEA (B)
00001236                           211  OOIX_BRA
00001236  0805 000C                212      BTST.L  #12,D5              * Test the second bit 
0000123A  6700 0032                213      BEQ     OOIO_BRA            * MOVE or MOVEA need to be handled here (W)
0000123E  6000 004E                214      BRA     OOII_BRA            * MOVE or MOVEA need to be handled here (L)
00001242                           215  
00001242                           216  OOOO_BRA                        * tests for ADDI or SUBI
00001242  343C 0F00                217      MOVE.W  #ADDSUBI_MASK,D2   * Load mask for ADDI temporarily into register for AND operation
00001246  C445                     218      AND.W   D5,D2               * AND with current opcode data and store into D2
00001248  B47C 0600                219      CMP.W   #$0600,D2           * Result of mask should be 0060 if the code is ADDi
0000124C  6700 0138                220      BEQ     DO_ADDI     
00001250  B47C 0400                221      CMP.W   #$0400,D2           * SUBI and ADDI  have the same bitmask.
00001254  6700 0178                222      BEQ     DO_SUBI
00001258  6000 0216                223      BRA     PRINT_INVALID_MSG
0000125C                           224  OOOI_BRA                        * MOVE and MOVEA need to be handled here (B)
0000125C  343C 3000                225      MOVE.W  #MOVE_MASK,D2
00001260  C445                     226      AND.W   D5,D2
00001262  B47C 1000                227      CMP.W   #$1000,D2           * is it a move byte?
00001266  6700 0090                228      BEQ     DO_MOVE_B           
0000126A                           229  
0000126A  6000 0204                230      BRA     PRINT_INVALID_MSG   *neither MoveA or Move? BADDDD
0000126E                           231  OOIO_BRA                        * MOVE and MOVEA need to be handled here (W)
0000126E  343C 31C0                232      MOVE.W  #MOVEA_MASK,D2
00001272  C445                     233      AND.W   D5,D2
00001274  B47C 2040                234      CMP.W   #$2040,D2           * is it a moveA word?
00001278  6700 0096                235      BEQ     DO_MOVEA_W          
0000127C                           236  
0000127C  343C 3000                237      MOVE.W  #MOVE_MASK,D2
00001280  C445                     238      AND.W   D5,D2
00001282  B47C 2000                239      CMP.W   #$2000,D2           * is it a move word?
00001286  6700 009A                240      BEQ     DO_MOVE_W           
0000128A                           241  
0000128A  6000 01E4                242      BRA     PRINT_INVALID_MSG
0000128E                           243  OOII_BRA                        * MOVE and MOVEA need to be handled here (L)
0000128E  343C 31C0                244      MOVE.W  #MOVEA_MASK,D2
00001292  C445                     245      AND.W   D5,D2
00001294  B47C 3040                246      CMP.W   #$3040,D2           * is it a moveA long?
00001298  6700 00A0                247      BEQ     DO_MOVEA_L          
0000129C                           248  
0000129C  343C 3000                249      MOVE.W  #MOVE_MASK,D2
000012A0  C445                     250      AND.W   D5,D2
000012A2  B47C 3000                251      CMP.W   #$3000,D2           * is it a move long?
000012A6  6700 00A4                252      BEQ     DO_MOVE_L           
000012AA                           253  
000012AA  6000 01C4                254      BRA     PRINT_INVALID_MSG
000012AE                           255  OIOX_BRA
000012AE  0805 000C                256      BTST.L  #12,D5
000012B2  6700 0012                257      BEQ     OIOO_BRA    * CLR, JSR, MOVEM, LEA   
000012B6  6000 0128                258      BRA     DO_ADDQ     * ADDQ 
000012BA                           259  OIIX_BRA
000012BA                           260      *check for MOVEQ and BCC here, which is 0110 always. there is no 0111
000012BA  0805 000C                261      BTST.L  #12,D5
000012BE  6700 00FC                262      BEQ     DO_Bcc            * BCC happens here, have to narrow it down to which one!
000012C2  6000 0188                263      BRA     DO_MOVEQ   
000012C6                           264  OIOO_BRA
000012C6                           265      ** Test for JSR
000012C6  343C 0FC0                266      MOVE.W  #JSR_MASK,D2 * Load mask temporarily into register for ANDing
000012CA  C445                     267      AND.W   D5,D2        * AND with the current opcode data
000012CC  B47C 0E80                268      CMP.W   #$0E80,D2    * Result of mask should be 0E80 if code is JSR
000012D0  6700 018C                269      BEQ     DO_JSR       *
000012D4                           270  
000012D4  343C 0F00                271      MOVE.W  #CLR_MASK,D2
000012D8  C445                     272      AND.W   D5,D2
000012DA  B47C 0200                273      CMP.W   #$0200,D2              * IS IT CLR?
000012DE  6700 0112                274      BEQ     DO_CLR
000012E2                           275  
000012E2  343C 01C0                276      MOVE.W  #LEA_MASK,D2
000012E6  C445                     277      AND     D5,D2
000012E8  B47C 01C0                278      CMP.W   #$01C0,D2              *EQUAL TO LEA?
000012EC  6700 0116                279      BEQ.W   DO_LEA
000012F0  6000 0190                280      BRA     PRINT_OIOO_ERROR       * if not RTS, not JSR, CLR, or LEA, then its invalid. 
000012F4                           281  
000012F4                           282  IXXX_BRA
000012F4  6000 019E                283      BRA     PRINT_COME_BACK_MSG   * temporary until further development of right branch
000012F8                           284      
000012F8                           285  DO_MOVE_B
000012F8  47F9 00001580            286      LEA     S_MOVE_B,A3
000012FE  1E3C 002A                287      MOVE.B  #$2A,D7         * for now, temporarily calling this mnemonic number 2, section a (which is a byte)
00001302  4EB9 000014A6            288      JSR     WRITE
00001308  4EB9 00001652            289      JSR     MOVE_EA
0000130E  4E75                     290      RTS
00001310                           291  DO_MOVEA_W
00001310  47F9 00001590            292      LEA     S_MOVEA_W,A3
00001316  1E3C 003B                293      MOVE.B  #$3B,D7         * for now, temporarily calling this mnemonic number 3, section b (which is a word)
0000131A                           294      ** Eventually, EA Module will be called here
0000131A  4EB9 000014A6            295      JSR     WRITE
00001320  4E75                     296      RTS
00001322                           297  DO_MOVE_W
00001322  47F9 000015A0            298      LEA     S_MOVE_W,A3
00001328  1E3C 002B                299      MOVE.B  #$2B,D7         * for now, temporarily calling this mnemonic number 2, section b (which is a word)
0000132C  4EB9 000014A6            300      JSR     WRITE
00001332  4EB9 00001652            301      JSR     MOVE_EA
00001338  4E75                     302      RTS
0000133A                           303  DO_MOVEA_L
0000133A  47F9 000015B0            304      LEA     S_MOVEA_L,A3
00001340  1E3C 003C                305      MOVE.B  #$3C,D7         * for now, temporarily calling this mnemonic number 3, section c (which is a long)
00001344                           306      ** Eventually, EA Module will be called here
00001344  4EB9 000014A6            307      JSR     WRITE
0000134A  4E75                     308      RTS
0000134C                           309  DO_MOVE_L
0000134C  47F9 000015C0            310      LEA     S_MOVE_L,A3
00001352  1E3C 002C                311      MOVE.B  #$2C,D7         * for now, temporarily calling this mnemonic number 2, section c (which is a long)
00001356  4EB9 000014A6            312      JSR     WRITE
0000135C  4EB9 00001652            313      JSR     MOVE_EA
00001362  4E75                     314      RTS
00001364                           315  
00001364                           316  DO_BCC_CASE
00001364  343C 0F00                317      MOVE.W  #Bcc_MASK,D2
00001368  C445                     318      AND     D5,D2
0000136A  B47C 0E00                319      CMP.W   #$0E00,D2                * Is it BGT?
0000136E  6700 0028                320      BEQ.W   DO_BGT
00001372                           321      
00001372  B47C 0F00                322      CMP.W   #$0F00,D2                * Is it BLE?
00001376  6700 0032                323      BEQ.W   DO_BLE
0000137A                           324  
0000137A  B47C 0400                325      CMP.W   #$0400,D2                * Is it BCC?
0000137E  6700 003C                326      BEQ.W   DO_BCC
00001382                           327  
00001382  6000 00EC                328      BRA     PRINT_INVALID_MSG        * none of these options? not required or invalid
00001386                           329  
00001386                           330  DO_ADDI
00001386  47F9 00001500            331      LEA     S_ADDI,A3
0000138C  1E3C 0008                332      MOVE.B  #8,D7
00001390                           333      ** Eventually, EA Module will be called here
00001390  4EB9 000014A6            334      JSR     WRITE
00001396  4E75                     335      RTS
00001398                           336  DO_BGT
00001398  47F9 00001550            337      LEA     S_BGT,A3
0000139E  1E3C 001A                338      MOVE.B  #26,D7
000013A2                           339      ** Eventually, EA Module will be called here
000013A2  4EB9 000014A6            340      JSR     WRITE
000013A8  4E75                     341      RTS
000013AA                           342  DO_BLE
000013AA  47F9 00001560            343      LEA     S_BLE,A3
000013B0  1E3C 001B                344      MOVE.B  #27,D7
000013B4                           345      ** Eventually, EA Module will be called here
000013B4  4EB9 000014A6            346      JSR     WRITE
000013BA  4E75                     347      RTS
000013BC                           348  DO_BCC
000013BC  47F9 00001570            349      LEA     S_BCC,A3
000013C2  1E3C 001C                350      MOVE.B  #28,D7
000013C6                           351      ** Eventually, EA Module will be called here
000013C6  4EB9 000014A6            352      JSR     WRITE
000013CC  4E75                     353      RTS
000013CE                           354  DO_SUBI
000013CE  47F9 00001510            355      LEA     S_SUBI,A3
000013D4  1E3C 000B                356      MOVE.B  #11,D7
000013D8                           357      ** Eventually, EA Module will be called here
000013D8  4EB9 000014A6            358      JSR     WRITE
000013DE  4E75                     359      RTS
000013E0                           360  DO_ADDQ
000013E0                           361      *Check for full opcode for 11 and onwards. if invalid, print the message
000013E0  47F9 000014F0            362      LEA     S_ADDQ,A3
000013E6  1E3C 0009                363      MOVE.B  #9,D7
000013EA                           364      ** Eventually, EA Module will be called here
000013EA  4EB9 000014A6            365      JSR     WRITE
000013F0  4E75                     366      RTS
000013F2                           367  DO_CLR
000013F2  47F9 00001520            368      LEA     S_CLR,A3
000013F8  1E3C 0010                369      MOVE.B  #16,D7
000013FC                           370      ** Eventually, EA Module will be called here
000013FC  4EB9 000014A6            371      JSR     WRITE
00001402  4E75                     372      RTS
00001404                           373  DO_LEA
00001404  47F9 00001530            374      LEA     S_LEA,A3    * Load the NOP string into A3 for WRITE subroutine
0000140A  1E3C 000F                375      MOVE.B  #15,D7       * Store key for op code for EA module
0000140E                           376      ** Eventually, EA Module will be called here
0000140E  4EB9 000014A6            377      JSR     WRITE       * Jump to WRITE subroutine
00001414  4E75                     378      RTS                 * Return to I/O module 
00001416                           379  DO_NOP
00001416  47F9 000014B0            380      LEA     S_NOP,A3    * Load the NOP string into A3 for WRITE subroutine
0000141C  1E3C 0001                381      MOVE.B  #1,D7       * Store key for op code for EA module
00001420                           382      ** Eventually, EA Module will be called here
00001420  4EB9 000014A6            383      JSR     WRITE       * Jump to WRITE subroutine
00001426  4E75                     384      RTS                 * Return to I/O module 
00001428                           385  DO_RTS
00001428  47F9 000014C0            386      LEA     S_RTS,A3    * Load the RTS string into A3 for WRITE subroutine
0000142E  1E3C 001E                387      MOVE.B  #30,D7      * Store key for op code for EA module
00001432                           388      ** Eventually, EA Module will be called here
00001432  4EB9 000014A6            389      JSR     WRITE       * Jump to WRITE subroutine
00001438  4E75                     390      RTS                 * Return to the I/O module bra op_decode  
0000143A                           391  DO_MOVE
0000143A  47F9 000014D0            392      LEA     S_MOVE,A3
00001440  1E3C 0002                393      MOVE.B  #2,D7
00001444                           394      ** Eventually, EA Module will be called here
00001444  4EB9 000014A6            395      JSR     WRITE
0000144A  4E75                     396      RTS
0000144C                           397  DO_MOVEQ
0000144C  47F9 00001540            398      LEA     S_MOVEQ,A3
00001452  1E3C 0004                399      MOVE.B  #4,D7
00001456  4EB9 000014A6            400      JSR     WRITE
0000145C  4E75                     401      RTS
0000145E                           402  DO_JSR
0000145E  47F9 000014E0            403      LEA     S_JSR,A3
00001464  1E3C 001B                404      MOVE.B  #27,D7
00001468                           405      ** Eventually, NOCK will be called here
00001468  4EB9 000014A6            406      JSR     WRITE
0000146E  4E75                     407      RTS
00001470                           408  PRINT_INVALID_MSG
00001470  47F9 000015D0            409      LEA     INVALID,A3
00001476  1E3C 0000                410      MOVE.B  #0,D7
0000147A                           411      ** Eventually, NOCK will be called here
0000147A  4EB9 000014A6            412      JSR     WRITE
00001480  4E75                     413      RTS
00001482                           414  PRINT_OIOO_ERROR
00001482  47F9 0000161F            415      LEA     BAD_OIOO,A3
00001488  1E3C 0000                416      MOVE.B  #0,D7
0000148C                           417      ** Eventually, NOCK will be called here
0000148C  4EB9 000014A6            418      JSR     WRITE
00001492  4E75                     419      RTS
00001494                           420  PRINT_COME_BACK_MSG
00001494  47F9 000015FC            421      LEA     COMEBK,A3
0000149A  1E3C 0000                422      MOVE.B  #0,D7
0000149E                           423      ** Eventually, NOCK will be called here
0000149E  4EB9 000014A6            424      JSR     WRITE
000014A4  4E75                     425      RTS
000014A6                           426  WRITE   * Writes string pointed to by A3 to memory pointed to by A1
000014A6                           427      *MOVEA.L A4,A1     * Save the position of A4 before writing (for I/0)
000014A6                           428  WRITE_LOOP
000014A6  18DB                     429      MOVE.B  (A3)+,(A4)+     * Write one byte and increment
000014A8  0C13 0000                430      CMP.B   #0,(A3)         * Are we at the null terminator?
000014AC  66F8                     431      BNE     WRITE_LOOP      * If not, keep going
000014AE                           432      *MOVE.B  #$2C,(A4)+     * Write the null terminator before exiting
000014AE  4E75                     433      RTS                     * Executes once null terminator was reached
000014B0                           434      
000014B0                           435  ;; ~~~~~~~~STRING CONSTANTS~~~~~~~~
000014B0                           436  
000014B0  =00004E71                437  CODE_NOP    EQU     $4E71
000014B0  =00004E75                438  CODE_RTS    EQU     $4E75
000014B0                           439  
000014B0  =00002000                440  A4_PREV     SET     $2000
000014B0                           441  
000014B0= 4E 4F 50 20 20 20 ...    442  S_NOP       DC.B    'NOP            ',0
000014C0= 52 54 53 20 20 20 ...    443  S_RTS       DC.B    'RTS            ',0
000014D0= 4D 4F 56 45 20 20 ...    444  S_MOVE      DC.B    'MOVE           ',0
000014E0= 4A 53 52 20 20 20 ...    445  S_JSR       DC.B    'JSR            ',0
000014F0= 41 44 44 51 20 20 ...    446  S_ADDQ      DC.B    'ADDQ           ',0
00001500= 41 44 44 49 20 20 ...    447  S_ADDI      DC.B    'ADDI           ',0
00001510= 53 55 42 49 20 20 ...    448  S_SUBI      DC.B    'SUBI           ',0
00001520= 43 4C 52 20 20 20 ...    449  S_CLR       DC.B    'CLR            ',0
00001530= 4C 45 41 20 20 20 ...    450  S_LEA       DC.B    'LEA            ',0
00001540= 4D 4F 56 45 51 20 ...    451  S_MOVEQ     DC.B    'MOVEQ          ',0
00001550= 42 47 54 20 20 20 ...    452  S_BGT       DC.B    'BGT            ',0
00001560= 42 4C 45 20 20 20 ...    453  S_BLE       DC.B    'BLE            ',0
00001570= 42 43 43 20 20 20 ...    454  S_BCC       DC.B    'BCC            ',0
00001580= 4D 4F 56 45 2E 42 ...    455  S_MOVE_B    DC.B    'MOVE.B         ',0
00001590= 4D 4F 56 45 41 2E ...    456  S_MOVEA_W   DC.B    'MOVEA.W        ',0
000015A0= 4D 4F 56 45 2E 57 ...    457  S_MOVE_W    DC.B    'MOVE.W         ',0
000015B0= 4D 4F 56 45 41 2E ...    458  S_MOVEA_L   DC.B    'MOVEA.L        ',0
000015C0= 4D 4F 56 45 2E 4C ...    459  S_MOVE_L    DC.B    'MOVE.L         ',0
000015D0                           460  
000015D0                           461  
000015D0= 49 4E 56 41 4C 49 ...    462  INVALID     DC.B    'INVALID OPCODE. LETS FIX THIS MESSAGE LATER',0
000015FC= 43 6F 6D 65 20 62 ...    463  COMEBK      DC.B    'Come back to me pls dont forget me',0 
0000161F= 42 61 64 20 4F 49 ...    464  BAD_OIOO    DC.B    'Bad OIOO maybe not JSR,RTS,CLR,LEA.. who knows.',0
0000164F                           465  
0000164F  =00000FC0                466  JSR_MASK        EQU     %0000111111000000
0000164F  =00000F00                467  ADDSUBI_MASK    EQU     %0000111100000000       ** come back and fix this to be the same but diferent comparisons 
0000164F  =00000000                468  BYTE_MASK       EQU     %0000000000000000       * Not sure if this is needed
0000164F  =00000040                469  WORD_MASK       EQU     %0000000001000000       * not sure if this is needed
0000164F  =00000080                470  LONG_MASK       EQU     %0000000010000000       * not sure if this is needed
0000164F  =00000F00                471  CLR_MASK        EQU     %0000111100000000
0000164F  =000001C0                472  LEA_MASK        EQU     %0000000111000000
0000164F  =00000F00                473  Bcc_MASK        EQU     %0000111100000000
0000164F                           474  
0000164F  =000031C0                475  MOVEA_MASK      EQU     %0011000111000000
0000164F  =00003000                476  MOVE_MASK       EQU     %0011000000000000
0000164F                           477  ;; ~*~*~*~*~*~*~*~END OPCODE MODULE~*~*~*~*~*~*~*~
0000164F                           478  
0000164F                           479  
0000164F                           480  
0000164F                           481  -------------------- end include --------------------
0000164F                           482      
00001650  4E71                     483      NOP                         * Ensures included files align on word boundary
00001652                           484      
00001652                           485      INCLUDE 'EA.X68'
00001652                           486  
00001652                           487  
00001652                           488  ;;;;;;;;;;; HEY HELLO HEY -----> WRITE A NULL TERM AT END OF DECODING A CMD!!! <------
00001652                           489  
00001652                           490  ;; ~*~*~*~*~*~*~*~BEGIN EA MODULE~*~*~*~*~*~*~*~
00001652                           491  
00001652                           492  
00001652                           493  
00001652                           494  
00001652                           495  
00001652                           496  ;; PROBABLY REMOVE THIS WRITE SR
00001652                           497  
00001652                           498  MOVE_EA
00001652                           499  
00001652                           500  ;; *~*~*~*~*~*~*~ pSeUdOcOdE ~*~*~*~*~*~*~* ;;
00001652                           501      * 1.) Mask 3 LSB into D6 (reg #)
00001652                           502      * 2.) ROR 3 bits
00001652                           503      * 3.) Mask 3 LSB into D0 (mode #)
00001652                           504      * 4.) Call mode-specific buffer writer (DO_MODE -> write_mode_x)
00001652                           505  ;; NOTES: there will be one mode-specific buffer writer for each mode.
00001652                           506  ;; The routine will write mode-specific strings to the buffer in addition to
00001652                           507  ;; the register number (converted to ASCII). Use A3 and A4 to do this.
00001652                           508      * 5.) Write a comma
00001652                           509      * 6.) ROR 3 bits
00001652                           510      * 7.) Mask 3 LSB into D0 (mode #)
00001652                           511      * 8.) ROR 3 bits
00001652                           512      * 9.) Mask 3 LSB into D6 (reg #)
00001652                           513      * 10.) Call mode-specific buffer writer
00001652                           514      * 11.) Return to I/O module
00001652                           515      
00001652                           516  
00001652  2C05                     517      MOVE.L  D5,D6               * D6 will be masked to hold only 3 LSB (reg #)
00001654  CC7C 0007                518      AND.W   #THREE_LSB_MASK,D6  * D6 now holds source register #
00001658  E65D                     519      ROR.W   #3,D5               * rotate by 3 bits. mode should now be 3 LSB
0000165A  2005                     520      MOVE.L  D5,D0               * D0 will hold the mode
0000165C  C07C 0007                521      AND.W   #THREE_LSB_MASK,D0  * D0 now holds source mode code
00001660  4EB9 00001682            522      JSR     DO_MODE             * Get source mode decoded and written to buffer
00001666                           523      
00001666                           524      ** CURRENT BUFFER STATE: MOVE.x         Xn
00001666                           525      
00001666  18FC 002C                526      MOVE.B  #',',(A4)+           * Write the comma between EA modes
0000166A  E65D                     527      ROR.W   #3,D5               * dest mode is now 3 LSB of D5
0000166C  2005                     528      MOVE.L  D5,D0               * Copy new rotated word into D0 for masking
0000166E  C07C 0007                529      AND.W   #THREE_LSB_MASK,D0  * D0 now holds dest mode code
00001672  E65D                     530      ROR.W   #3,D5               * source register is now 3 LSB of D5
00001674  2C05                     531      MOVE.L  D5,D6               * Copy new rotated word into D6 for masking
00001676  CC7C 0007                532      AND.W   #THREE_LSB_MASK,D6  * mask source register into D6
0000167A  4EB9 00001682            533      JSR     DO_MODE             * Get dest mode decoded and written to buffer
00001680                           534      
00001680                           535      ** FINAL BUFFER STATE: MOVE.x         Xn,Xn
00001680                           536      
00001680  4E75                     537      RTS
00001682                           538      
00001682                           539      
00001682                           540      
00001682                           541  ;; Finds the mode stored in D6 and branches to appropriate SR to write to the buffer
00001682                           542  DO_MODE
00001682  B03C 0000                543      CMP.B   #00,D0      ** Mode 0 - Data Register Direct
00001686  6700 0024                544      BEQ     DR_DIRECT
0000168A                           545      
0000168A  B03C 0001                546      CMP.B   #01,D0      ** Mode 1 - Address Register Direct
0000168E  6700 0028                547      BEQ     AR_DIRECT   
00001692                           548      
00001692  B03C 0002                549      CMP.B   #02,D0      ** Mode 2 - Address Register Indirect
00001696  6700 0020                550      BEQ     AR_INDIRECT
0000169A                           551      
0000169A  B03C 0003                552      CMP.B   #03,D0      ** Mode 3 - Address Register Indirect w/ Post-increment
0000169E  6700 0018                553      BEQ     AR_POSTINC
000016A2                           554      
000016A2  B03C 0004                555      CMP.B   #04,D0      ** Mode 4 - Address Register Indirect w/ Pre-decrement
000016A6  6700 0010                556      BEQ     AR_PREDEC
000016AA                           557      
000016AA                           558      ** HERE: check for non-required EA modes (101, 110, 111 w/ 010 in Xn, 111 w/ 011 in Xn)
000016AA                           559      ** if found, branch to "unsupported EA mode" branch
000016AA                           560      
000016AA  4E75                     561      RTS
000016AC                           562  
000016AC                           563  
000016AC                           564  DR_DIRECT   *** Mode 0
000016AC  18FC 0044                565      MOVE.B  #'D',(A4)+   * Write D to the buffer
000016B0  0606 0030                566      ADDI.B  #$30,D6     * Add $30 to the register number to convert to ASCII
000016B4  18C6                     567      MOVE.B  D6,(A4)+    * Write the ASCII-converted number to the buffer
000016B6  4E75                     568      RTS
000016B8                           569  
000016B8                           570  AR_DIRECT   *** Mode 1
000016B8                           571      
000016B8                           572  
000016B8                           573  AR_INDIRECT *** Mode 2
000016B8                           574      * WRITE (A
000016B8                           575      * WRITE NUMBER IN D6
000016B8                           576      * WRITE )
000016B8                           577  
000016B8                           578  AR_POSTINC  *** Mode 3
000016B8                           579      * WRITE (A
000016B8                           580      * WRITE NUMBER IN D6
000016B8                           581      * WRITE )+
000016B8                           582      
000016B8                           583  AR_PREDEC   *** Mode 4
000016B8                           584      * WRITE -(A
000016B8                           585      * WRITE NUMBER IN D6
000016B8                           586      * WRITE )
000016B8                           587  
000016B8                           588  IMM_DATA
000016B8                           589      * HOW TO DO THIS?
000016B8                           590  
000016B8                           591  ABS_LONG
000016B8                           592      * GET LONG FROM (A6)+
000016B8                           593      * WRITE $
000016B8                           594      * WRITE DATA GOT FROM A6
000016B8                           595  
000016B8                           596  ABS_WORD
000016B8                           597      * GET WORD FROM (A6)+
000016B8                           598      * WRITE $
000016B8                           599      * WRITE DATA GOT FROM A6
000016B8                           600      
000016B8                           601  
000016B8  =00000007                602  THREE_LSB_MASK  EQU     %0000000000000111
000016B8                           603  
000016B8                           604  ;; ~*~*~*~*~*~*~*~END EA MODULE~*~*~*~*~*~*~*~
000016B8                           605  
000016B8                           606      END    START        ; last line of source
000016B8                           607  -------------------- end include --------------------

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A4_PREV             2000
ABS_LONG            16B8
ABS_WORD            16B8
ADDR_PRMPT_END      1182
ADDR_PRMPT_STRT     115F
ADDSUBI_MASK        F00
AR_DIRECT           16B8
AR_INDIRECT         16B8
AR_POSTINC          16B8
AR_PREDEC           16B8
ASC_CHAR_MAX        46
ASC_CHAR_MIN        41
ASC_NUM_MAX         39
ASC_NUM_MIN         30
ASC_TO_CHAR         1096
ASC_TO_NUM          108C
BAD_OIOO            161F
BCC_MASK            F00
BYTE_MASK           0
CHECK_CHAR_MAX      1080
CHECK_CHAR_MIN      1074
CHECK_NUM_MAX       1066
CHECK_NUM_MIN       105A
CLR_MASK            F00
CODE_NOP            4E71
CODE_RTS            4E75
COMEBK              15FC
CONVERSION_LOOP     1058
CR                  D
DISM_CODE           8000
DONE_MSG            10F9
DO_ADDI             1386
DO_ADDQ             13E0
DO_BCC              13BC
DO_BCC_CASE         1364
DO_BGT              1398
DO_BLE              13AA
DO_CLR              13F2
DO_JSR              145E
DO_LEA              1404
DO_MODE             1682
DO_MOVE             143A
DO_MOVEA_L          133A
DO_MOVEA_W          1310
DO_MOVEQ            144C
DO_MOVE_B           12F8
DO_MOVE_L           134C
DO_MOVE_W           1322
DO_NOP              1416
DO_RTS              1428
DO_SUBI             13CE
DR_DIRECT           16AC
END_LTE_BEG         111C
END_NOW             11D4
ERROR_END_LTE_BEG   10BC
ERROR_INV_INP       10AC
IMM_DATA            16B8
INVALID             15D0
INVALID_INPUT       10FF
IXXX_BRA            12F4
JSR_MASK            FC0
LEA_MASK            1C0
LF                  A
LONG_MASK           80
MAIN_LOOP           10CC
MOVEA_MASK          31C0
MOVE_EA             1652
MOVE_MASK           3000
NEW_LINE            10F6
OIIX_BRA            12BA
OIOO_BRA            12C6
OIOX_BRA            12AE
OIXX_BRA            121E
OOII_BRA            128E
OOIO_BRA            126E
OOIX_BRA            1236
OOOI_BRA            125C
OOOO_BRA            1242
OOOX_BRA            122A
OOXX_BRA            120E
OP_DECODE           11DE
OXXX_BRA            1202
PRINT_COME_BACK_MSG  1494
PRINT_INVALID_MSG   1470
PRINT_IT_STRING     11A4
PRINT_OIOO_ERROR    1482
SHIFTS              10A0
START               1000
S_ADDI              1500
S_ADDQ              14F0
S_BCC               1570
S_BGT               1550
S_BLE               1560
S_CLR               1520
S_JSR               14E0
S_LEA               1530
S_MOVE              14D0
S_MOVEA_L           15B0
S_MOVEA_W           1590
S_MOVEQ             1540
S_MOVE_B            1580
S_MOVE_L            15C0
S_MOVE_W            15A0
S_NOP               14B0
S_RTS               14C0
S_SUBI              1510
THREE_LSB_MASK      7
WORD_MASK           40
WRITE               14A6
WRITE_LOOP          14A6
