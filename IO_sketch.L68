00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/17/2018 12:14:59 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler I/O 
00000000                             3  * Written by :  touCANs
00000000                             4  * Date       :  5/1/18 - 
00000000                             5  * Description:  I/O functionality for the disassembler 
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000  43F9 000011C2             11      LEA     ADDR_PRMPT_STRT,A1
00001006  103C 000E                 12      MOVE.B  #14,D0
0000100A  4E4F                      13      TRAP    #15
0000100C                            14  
0000100C  43F9 00001234             15      LEA     buffer,A1       * Load buffer's effective address into A1
00001012  103C 0002                 16      MOVE.B  #2,D0           * get the starting address from the user as a string
00001016  4E4F                      17      TRAP    #15         
00001018                            18      
00001018                            19  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
00001018  B27C 0004                 20      CMP     #4,D1           * minimum of a word for the address
0000101C  6D00 008E                 21      BLT     ERROR_INV_INP   * invalid start address  
00001020                            22      
00001020  4EB9 00001058             23      JSR     CONVERSION_LOOP * convert the starting address
00001026                            24      
00001026                            25  *** FULL STARTING ADDRESS HAS BEEN CONVERTED, STORE IN A6 AND GET ENDING ADDRESSS
00001026  2C42                      26      MOVEA.L D2,A6           * move converted addr to A6 (A6 acts as iterator while disassembling)
00001028  4282                      27      CLR.L   D2              * clear register D2 in preparation to hold the converted end address
0000102A  4284                      28      CLR.L   D4              * clear register D4 to start the counter at 0 again
0000102C                            29      
0000102C  43F9 000011E5             30      LEA     ADDR_PRMPT_END,A1
00001032  103C 000E                 31      MOVE.B  #14,D0
00001036  4E4F                      32      TRAP    #15
00001038                            33      
00001038  103C 0002                 34      MOVE.B  #2,D0           * get the ending address from the user as a string
0000103C  4E4F                      35      TRAP    #15
0000103E                            36      
0000103E                            37  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
0000103E  B27C 0004                 38      CMP     #4,D1           * minimum of a word for the address
00001042  6D00 0068                 39      BLT     ERROR_INV_INP   * invalid end address
00001046                            40      
00001046  4EB9 00001058             41      JSR     CONVERSION_LOOP * convert the ending address
0000104C  2A42                      42      MOVEA.L D2,A5           * move converted addr to A5 (compare A6 to A5 to know when to stop)
0000104E  BDCD                      43      CMPA.L  A5,A6           * check if beginning address is >= end address. If so, display error
00001050  6C00 006A                 44      BGE     ERROR_END_LTE_BEG
00001054  6000 0076                 45      BRA     MAIN_LOOP       * skip past the CONVERSION_LOOP subroutine to continue with the program
00001058                            46      
00001058                            47  
00001058                            48  
00001058                            49  *    ADDI.B  #1,D4           * offset our counter to start at 1
00001058                            50  
00001058                            51  
00001058                            52  ;; ~~~~~~~~BEGINNING OF CONVERSION SUBROUTINE~~~~~~~~
00001058                            53  CONVERSION_LOOP       
00001058  1619                      54      MOVE.B  (A1)+,D3        * store the next thingy B
0000105A                            55  *** Need to check for proper hex conversion 
0000105A                            56  
0000105A                            57  CHECK_NUM_MIN     ;; Checks if number is >= 30 (0) in ASCII
0000105A  B67C 0030                 58      CMP     #ASC_NUM_MIN,D3 * Range of ASCII numbers: (2F >= 3A)[2F,3A] then subtract 30    
0000105E  6C00 0006                 59      BGE     CHECK_NUM_MAX   * check if it's in range for x > 2F
00001062  6000 0048                 60      BRA     ERROR_INV_INP   * First condition not met, go to bad input error 
00001066                            61      
00001066                            62  CHECK_NUM_MAX     ;; Checks if number is <= 39 (9) in ASCII
00001066  B67C 0039                 63      CMP     #ASC_NUM_MAX,D3
0000106A  6F00 0020                 64      BLE     ASC_TO_NUM      * If condition for the range was met, do the math
0000106E  4EF9 00001074             65      JMP     CHECK_CHAR_MIN  * Second condition was not met, check if a character
00001074                            66      
00001074                            67  CHECK_CHAR_MIN    ;; Checks if number is >= 41 (A) in ASCII
00001074  B67C 0041                 68      CMP     #ASC_CHAR_MIN,D3
00001078  6C00 0006                 69      BGE     CHECK_CHAR_MAX  
0000107C  6000 002E                 70      BRA     ERROR_INV_INP   * First condition not met, D3 < 41 = symbols. Go to bad input error
00001080                            71      
00001080                            72  CHECK_CHAR_MAX    ;; Checks if number is <= 46 (F) in ASCII
00001080  B67C 0046                 73      CMP     #ASC_CHAR_MAX,D3
00001084  6F00 0010                 74      BLE     ASC_TO_CHAR     * Condition was met for A-F     
00001088  6000 0022                 75      BRA     ERROR_INV_INP   * Greater than 46 = out of 16-bit system
0000108C                            76      
0000108C                            77  ASC_TO_NUM        ;; Converts a string digit into a hex value
0000108C  0403 0030                 78      SUBI.B  #$30,D3
00001090  4EF9 000010A0             79      JMP     SHIFTS          * After this routine is finished, complete shifts/adds
00001096                            80      
00001096                            81  ASC_TO_CHAR       ;; Converts a string character into a hex value
00001096  0403 0037                 82      SUBI.B  #$37,D3    
0000109A  4EF9 000010A0             83      JMP     SHIFTS          * Convert a string character into a hex value
000010A0                            84      
000010A0                            85  SHIFTS            ;; Shifts D2 left by four bits to make room for the newly converted hexabit
000010A0  E98A                      86      LSL.L   #4,D2           * Initial value in D2 shifted hexabit over to the left to make room   
000010A2  D403                      87      ADD.B   D3,D2           * Add modified value from D3 into D2.
000010A4                            88      
000010A4  5204                      89      ADD.B   #1,D4           * Increment counter by 1 
000010A6  B244                      90      CMP     D4,D1           * Check if we have already reached the end of the input. D4 = counter
000010A8  66AE                      91      BNE     CONVERSION_LOOP * Continue back to the loop if D4 != D1  
000010AA  4E75                      92      RTS
000010AC                            93  ;; ~~~~~~~~END OF CONVERSION SUBROUTINE~~~~~~~~
000010AC                            94      
000010AC                            95      
000010AC                            96      
000010AC                            97  ERROR_INV_INP ;; Prints the INVALID_INPUT error message to the console
000010AC  43F9 00001162             98      LEA     INVALID_INPUT,A1
000010B2  103C 000D                 99      MOVE.B  #13,D0
000010B6  4E4F                     100      TRAP    #15
000010B8  6000 0314                101      BRA     END_NOW
000010BC                           102      
000010BC                           103  ERROR_END_LTE_BEG ;; Prints the END_LTE_BEG (end <= to beginning) error message to the console.
000010BC  43F9 0000117F            104      LEA     END_LTE_BEG,A1
000010C2  103C 000D                105      MOVE.B  #13,D0
000010C6  4E4F                     106      TRAP    #15
000010C8  6000 0304                107      BRA     END_NOW
000010CC                           108    
000010CC                           109    
000010CC                           110  MAIN_LOOP
000010CC                           111      *BRA     END_NOW
000010CC  BDCD                     112      CMPA.L  A5,A6
000010CE  6C00 02FE                113      BGE     END_NOW
000010D2  6000 02B0                114      BRA     OP_DECODE
000010D6  207C 00000913            115      MOVEA.L #A1_PREV,A0
000010DC                           116      
000010DC                           117  PRINT_LOOP ;; Print the most recently decoded line
000010DC                           118      * If finished printing, return to decode loop
000010DC  B3C8                     119      CMP.L   A0,A1
000010DE  6CEC                     120      BGE     MAIN_LOOP
000010E0  1218                     121      MOVE.B  (A0)+,D1    * Load the byte at A0 to D1 to print
000010E2                           122      
000010E2  103C 0006                123      MOVE.B  #6,D0       * Trap task 6 to print the byte in D1
000010E6  4E4F                     124      TRAP    #15
000010E8  60F2                     125      BRA     PRINT_LOOP
000010EA                           126      
000010EA                           127      
000010EA                           128      
000010EA                           129    
000010EA                           130  ;; print nops
000010EA                           131  PRINT_NOPS_TEST
000010EA  103C 000F                132      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
000010EE  143C 0010                133      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
000010F2                           134      * PRINT THE CURRENT ADDRESS
000010F2  220E                     135      MOVE.L  A6,D1
000010F4  4E4F                     136      TRAP    #15
000010F6  4281                     137      CLR.L   D1          * clear D1 so that it holds just the data on the next print
000010F8                           138      
000010F8  43F9 0000115F            139      LEA     COLON_SPACE,A1
000010FE  103C 000E                140      MOVE.B  #14,D0
00001102  4E4F                     141      TRAP    #15
00001104                           142      
00001104  103C 0001                143      MOVE.B  #1,D0   * Print string, no CRLF
00001108                           144      
00001108                           145      
00001108                           146      
00001108                           147      
00001108                           148  
00001108                           149  ;; ~~~~~~~~BEGINNING OF PRINT LOOP~~~~~~~~   
00001108                           150  PRINT_IT          ;; Placeholder for now; just prints all data between start and end
00001108  43F9 00001207            151      LEA     PRINT_IT_STRING,A1
0000110E  103C 000D                152      MOVE.B  #13,D0
00001112  4E4F                     153      TRAP    #15
00001114                           154      
00001114                           155  PRINT_IT_LOOP
00001114  103C 000F                156      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
00001118  143C 0010                157      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
0000111C                           158      * PRINT THE CURRENT ADDRESS
0000111C  220E                     159      MOVE.L  A6,D1
0000111E  4E4F                     160      TRAP    #15
00001120  4281                     161      CLR.L   D1          * clear D1 so that it holds just the data on the next print
00001122                           162      
00001122  43F9 0000115F            163      LEA     COLON_SPACE,A1
00001128  103C 000E                164      MOVE.B  #14,D0
0000112C  4E4F                     165      TRAP    #15
0000112E                           166      
0000112E  221E                     167      MOVE.L  (A6)+,D1    * move the data at the pointer into D1 and increment.
00001130  103C 000F                168      MOVE.B  #15,D0      * Trap task 15 to print a signed number in the base in D2
00001134  4E4F                     169      TRAP    #15
00001136                           170      
00001136                           171      * Print a new line
00001136  43F9 00001156            172      LEA     NEW_LINE,A1
0000113C  103C 000D                173      MOVE.B  #13,D0
00001140  4E4F                     174      TRAP    #15
00001142                           175      
00001142                           176      * Check if end address has been reached
00001142  BDCD                     177      CMP.L   A5,A6
00001144  6FCE                     178      BLE     PRINT_IT_LOOP
00001146                           179  ;; ~~~~~~~~END OF PRINT LOOP~~~~~~~~
00001146                           180  
00001146                           181  
00001146                           182      
00001146                           183      
00001146  43F9 00001159            184      LEA     DONE_MSG,A1
0000114C  103C 000D                185      MOVE.B  #13,D0
00001150  4E4F                     186      TRAP    #15
00001152                           187  
00001152  FFFF FFFF                188      SIMHALT             ; halt simulator
00001156                           189  
00001156                           190  * Put variables and constants here
00001156                           191  
00001156                           192  *** ASCII constants used in the conversion loop. Subtract these from an ASCII character to get its
00001156                           193  *** real hex value (depending on whether it's a digit or a character).
00001156  =00000030                194  ASC_NUM_MIN     EQU     $30     * ASCII key for 0
00001156  =00000039                195  ASC_NUM_MAX     EQU     $39     * ASCII key for 9
00001156  =00000041                196  ASC_CHAR_MIN    EQU     $41     * ASCII key for A
00001156  =00000046                197  ASC_CHAR_MAX    EQU     $46     * ASCII key for F
00001156                           198  
00001156                           199  *** Message strings
00001156                           200      * Temporary; used for debugging and testing
00001156= 00 0D 0A                 201  NEW_LINE        DC.B    '',0,CR,LF
00001159                           202      * Temporary; used for debugging and testing
00001159= 44 6F 6E 65 2E 00        203  DONE_MSG        DC.B    'Done.',0
0000115F                           204      * Temporary; used for debugging and testing
0000115F= 3A 20 00                 205  COLON_SPACE     DC.B    ': ',0
00001162= 49 6E 76 61 6C 69 ...    206  INVALID_INPUT   DC.B    'Invalid input! Out of Range.',0
0000117F= 49 6E 76 61 6C 69 ...    207  END_LTE_BEG     DC.B    'Invalid input! End address is less than or equal to start address.',0  
000011C2= 45 6E 74 65 72 20 ...    208  ADDR_PRMPT_STRT DC.B    'Enter a starting address in hex: $',0
000011E5= 45 6E 74 65 72 20 ...    209  ADDR_PRMPT_END  DC.B    'Enter an ending address in hex: $',0
00001207= 49 20 61 6D 20 61 ...    210  PRINT_IT_STRING DC.B    'I am a PRINT_IT string. It is printing time!',0
00001234  =0000000A                211  LF              EQU      $0A
00001234  =0000000D                212  CR              EQU      $0D
00001234                           213  
00001234= 00000000 00000000 ...    214  buffer  DCB.L    84,0
00001384                           215  
00001384                           216      INCLUDE 'OP.x68'
00001384                           217  
00001384                           218  ;; ~*~*~*~*~*~*~*~BEGIN OPCODE MODULE~*~*~*~*~*~*~*~
00001384                           219  
00001384                           220  OP_DECODE
00001384  3A1E                     221      MOVE.W  (A6)+,D5     * Load the next opcode to decode into D5, incrementing
00001386                           222      * NOTE: A6 now points at either the next opcode or imm. data for EA part
00001386                           223      
00001386                           224      * is it NOP?
00001386  BA7C 4E71                225      CMP.W   #CODE_NOP,D5
0000138A  6700 000C                226      BEQ     DO_NOP       * This will take it on back to the I/O module
0000138E                           227      
0000138E                           228      * is it RTS?
0000138E  BA7C 4E75                229      CMP.W   #CODE_RTS,D5
00001392  6700 0012                230      BEQ     DO_RTS       * This will take it on back to the I/O module
00001396                           231      
00001396  4E75                     232      RTS * Return to I/O module (temporary; will go to EA module eventually)
00001398                           233      
00001398                           234      
00001398                           235  ;; ~~~~~~~~CHUNKS FOR WRITING DECODED OPS TO MEMORY~~~~~~~~
00001398                           236  
00001398                           237  ;; Typical structure for these chunks:
00001398                           238  
00001398                           239  DO_NOP
00001398  47F9 000013C6            240      LEA     S_NOP,A3    * Load the NOP string into A3 for WRITE subroutine
0000139E  4EB9 000013B4            241      JSR     WRITE       * Jump to WRITE subroutine
000013A4  4E75                     242      RTS                 * Return to I/O module 
000013A6                           243      
000013A6                           244  
000013A6                           245  DO_RTS
000013A6  47F9 000013CA            246      LEA     S_RTS,A3    * Load the RTS string into A3 for WRITE subroutine
000013AC  4EB9 000013B4            247      JSR     WRITE       * Jump to WRITE subroutine
000013B2  4E75                     248      RTS                 * Return to the I/O module
000013B4                           249     
000013B4                           250  WRITE   * Writes string pointed to by A3 to memory pointed to by A1
000013B4  23C9 00000913            251      MOVE.L  A1,A1_PREV      * Save the position of A1 before writing (for I/0)
000013BA                           252  WRITE_LOOP
000013BA  12DB                     253      MOVE.B  (A3)+,(A1)+     * Write one byte and increment
000013BC  0C13 0000                254      CMP.B   #0,(A3)         * Are we at the null terminator?
000013C0  66F8                     255      BNE     WRITE_LOOP         * If not, keep going
000013C2  12DB                     256      MOVE.B  (A3)+,(A1)+     * Write the null terminator before exiting
000013C4  4E75                     257      RTS                     * Executes once null terminator was reached
000013C6                           258      
000013C6                           259  ;; ~~~~~~~~STRING CONSTANTS~~~~~~~~
000013C6                           260  
000013C6  =00004E71                261  CODE_NOP    EQU     $4E71
000013C6  =00004E75                262  CODE_RTS    EQU     $4E75
000013C6                           263  
000013C6  =00000913                264  A1_PREV     SET     2323
000013C6                           265  
000013C6= 4E 4F 50 00              266  S_NOP   DC.B    'NOP',0
000013CA= 52 54 53 00              267  S_RTS   DC.B    'RTS',0
000013CE                           268  
000013CE                           269  ;; ~*~*~*~*~*~*~*~END OPCODE MODULE~*~*~*~*~*~*~*~
000013CE                           270  -------------------- end include --------------------
000013CE                           271  
000013CE                           272  END_NOW
000013CE  43F8 1159                273      LEA     DONE_MSG,A1
000013D2  103C 0001                274      MOVE.B  #1,D0
000013D6  4E4F                     275      TRAP    #15
000013D8  43F8 1234                276      LEA     buffer,A1
000013DC                           277      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A1_PREV             913
ADDR_PRMPT_END      11E5
ADDR_PRMPT_STRT     11C2
ASC_CHAR_MAX        46
ASC_CHAR_MIN        41
ASC_NUM_MAX         39
ASC_NUM_MIN         30
ASC_TO_CHAR         1096
ASC_TO_NUM          108C
BUFFER              1234
CHECK_CHAR_MAX      1080
CHECK_CHAR_MIN      1074
CHECK_NUM_MAX       1066
CHECK_NUM_MIN       105A
CODE_NOP            4E71
CODE_RTS            4E75
COLON_SPACE         115F
CONVERSION_LOOP     1058
CR                  D
DONE_MSG            1159
DO_NOP              1398
DO_RTS              13A6
END_LTE_BEG         117F
END_NOW             13CE
ERROR_END_LTE_BEG   10BC
ERROR_INV_INP       10AC
INVALID_INPUT       1162
LF                  A
MAIN_LOOP           10CC
NEW_LINE            1156
OP_DECODE           1384
PRINT_IT            1108
PRINT_IT_LOOP       1114
PRINT_IT_STRING     1207
PRINT_LOOP          10DC
PRINT_NOPS_TEST     10EA
SHIFTS              10A0
START               1000
S_NOP               13C6
S_RTS               13CA
WRITE               13B4
WRITE_LOOP          13BA
