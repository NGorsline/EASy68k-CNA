00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/26/2018 5:43:30 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler I/O 
00000000                             3  * Written by :  touCANs
00000000                             4  * Date       :  5/1/18 - 
00000000                             5  * Description:  I/O functionality for the disassembler 
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000  287C 00008000             11      MOVEA.L #DISM_CODE,A4
00001006                            12      
00001006  43F9 000011C4             13      LEA     ADDR_PRMPT_STRT,A1
0000100C  103C 000E                 14      MOVE.B  #14,D0
00001010  4E4F                      15      TRAP    #15
00001012                            16  
00001012  224C                      17      MOVEA.L A4,A1           * Initialize A1 to point at same place as A4
00001014  103C 0002                 18      MOVE.B  #2,D0           * get the starting address from the user as a string
00001018                            19      
00001018  4E4F                      20      TRAP    #15         
0000101A                            21      
0000101A                            22  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
0000101A  B27C 0004                 23      CMP     #4,D1           * minimum of a word for the address
0000101E  6D00 008E                 24      BLT     ERROR_INV_INP   * invalid start address  
00001022                            25      
00001022  4EB9 0000105A             26      JSR     CONVERSION_LOOP * convert the starting address
00001028                            27      
00001028                            28  *** FULL STARTING ADDRESS HAS BEEN CONVERTED, STORE IN A6 AND GET ENDING ADDRESSS
00001028  2C42                      29      MOVEA.L D2,A6           * move converted addr to A6 (A6 acts as iterator while disassembling)
0000102A  4282                      30      CLR.L   D2              * clear register D2 in preparation to hold the converted end address
0000102C  4284                      31      CLR.L   D4              * clear register D4 to start the counter at 0 again
0000102E                            32      
0000102E  43F9 000011E7             33      LEA     ADDR_PRMPT_END,A1
00001034  103C 000E                 34      MOVE.B  #14,D0
00001038  4E4F                      35      TRAP    #15
0000103A                            36      
0000103A  103C 0002                 37      MOVE.B  #2,D0           * get the ending address from the user as a string
0000103E  4E4F                      38      TRAP    #15
00001040                            39      
00001040                            40  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
00001040  B27C 0004                 41      CMP     #4,D1           * minimum of a word for the address
00001044  6D00 0068                 42      BLT     ERROR_INV_INP   * invalid end address
00001048                            43      
00001048  4EB9 0000105A             44      JSR     CONVERSION_LOOP * convert the ending address
0000104E  2A42                      45      MOVEA.L D2,A5           * move converted addr to A5 (compare A6 to A5 to know when to stop)
00001050  BDCD                      46      CMPA.L  A5,A6           * check if beginning address is >= end address. If so, display error
00001052  6C00 006A                 47      BGE     ERROR_END_LTE_BEG
00001056  6000 0076                 48      BRA     MAIN_LOOP       * skip past the CONVERSION_LOOP subroutine to continue with the program
0000105A                            49      
0000105A                            50  
0000105A                            51  
0000105A                            52  *    ADDI.B  #1,D4           * offset our counter to start at 1
0000105A                            53  
0000105A                            54  
0000105A                            55  ;; ~~~~~~~~BEGINNING OF CONVERSION SUBROUTINE~~~~~~~~
0000105A                            56  CONVERSION_LOOP       
0000105A  1619                      57      MOVE.B  (A1)+,D3        * store the next thingy B
0000105C                            58  *** Need to check for proper hex conversion 
0000105C                            59  
0000105C                            60  CHECK_NUM_MIN     ;; Checks if number is >= 30 (0) in ASCII
0000105C  B67C 0030                 61      CMP     #ASC_NUM_MIN,D3 * Range of ASCII numbers: (2F >= 3A)[2F,3A] then subtract 30    
00001060  6C00 0006                 62      BGE     CHECK_NUM_MAX   * check if it's in range for x > 2F
00001064  6000 0048                 63      BRA     ERROR_INV_INP   * First condition not met, go to bad input error 
00001068                            64      
00001068                            65  CHECK_NUM_MAX     ;; Checks if number is <= 39 (9) in ASCII
00001068  B67C 0039                 66      CMP     #ASC_NUM_MAX,D3
0000106C  6F00 0020                 67      BLE     ASC_TO_NUM      * If condition for the range was met, do the math
00001070  4EF9 00001076             68      JMP     CHECK_CHAR_MIN  * Second condition was not met, check if a character
00001076                            69      
00001076                            70  CHECK_CHAR_MIN    ;; Checks if number is >= 41 (A) in ASCII
00001076  B67C 0041                 71      CMP     #ASC_CHAR_MIN,D3
0000107A  6C00 0006                 72      BGE     CHECK_CHAR_MAX  
0000107E  6000 002E                 73      BRA     ERROR_INV_INP   * First condition not met, D3 < 41 = symbols. Go to bad input error
00001082                            74      
00001082                            75  CHECK_CHAR_MAX    ;; Checks if number is <= 46 (F) in ASCII
00001082  B67C 0046                 76      CMP     #ASC_CHAR_MAX,D3
00001086  6F00 0010                 77      BLE     ASC_TO_CHAR     * Condition was met for A-F     
0000108A  6000 0022                 78      BRA     ERROR_INV_INP   * Greater than 46 = out of 16-bit system
0000108E                            79      
0000108E                            80  ASC_TO_NUM        ;; Converts a string digit into a hex value
0000108E  0403 0030                 81      SUBI.B  #$30,D3
00001092  4EF9 000010A2             82      JMP     SHIFTS          * After this routine is finished, complete shifts/adds
00001098                            83      
00001098                            84  ASC_TO_CHAR       ;; Converts a string character into a hex value
00001098  0403 0037                 85      SUBI.B  #$37,D3    
0000109C  4EF9 000010A2             86      JMP     SHIFTS          * Convert a string character into a hex value
000010A2                            87      
000010A2                            88  SHIFTS            ;; Shifts D2 left by four bits to make room for the newly converted hexabit
000010A2  E98A                      89      LSL.L   #4,D2           * Initial value in D2 shifted hexabit over to the left to make room   
000010A4  D403                      90      ADD.B   D3,D2           * Add modified value from D3 into D2.
000010A6                            91      
000010A6  5204                      92      ADD.B   #1,D4           * Increment counter by 1 
000010A8  B244                      93      CMP     D4,D1           * Check if we have already reached the end of the input. D4 = counter
000010AA  66AE                      94      BNE     CONVERSION_LOOP * Continue back to the loop if D4 != D1  
000010AC  4E75                      95      RTS
000010AE                            96  ;; ~~~~~~~~END OF CONVERSION SUBROUTINE~~~~~~~~
000010AE                            97      
000010AE                            98      
000010AE                            99      
000010AE                           100  ERROR_INV_INP ;; Prints the INVALID_INPUT error message to the console
000010AE  43F9 00001164            101      LEA     INVALID_INPUT,A1
000010B4  103C 000D                102      MOVE.B  #13,D0
000010B8  4E4F                     103      TRAP    #15
000010BA  6000 0182                104      BRA     END_NOW
000010BE                           105      
000010BE                           106  ERROR_END_LTE_BEG ;; Prints the END_LTE_BEG (end <= to beginning) error message to the console.
000010BE  43F9 00001181            107      LEA     END_LTE_BEG,A1
000010C4  103C 000D                108      MOVE.B  #13,D0
000010C8  4E4F                     109      TRAP    #15
000010CA  6000 0172                110      BRA     END_NOW
000010CE                           111    
000010CE                           112    
000010CE                           113  MAIN_LOOP
000010CE                           114      *BRA     END_NOW
000010CE  BDCD                     115      CMPA.L  A5,A6
000010D0  6C00 016C                116      BGE     END_NOW * End program
000010D4                           117      *MOVE.W  A6,D0   * Copy A6 location to restore after jump to SR
000010D4  4EB9 00001248            118      JSR     OP_DECODE
000010DA                           119      
000010DA                           120  PRINT_LOOP ;; Print the most recently decoded line
000010DA                           121      * FIRST put a null terminator at (A4) [write loop in EA module does not do this]
000010DA  47F9 00001236            122      LEA     NULL_TERM,A3
000010E0  18D3                     123      MOVE.B  (A3),(A4)+    * This way trap task 13 works
000010E2  103C 000D                124      MOVE.B  #13,D0
000010E6  4E4F                     125      TRAP    #15
000010E8  224C                     126      MOVEA.L A4,A1         * Inch up A1 to match A4 for next print
000010EA  60E2                     127      BRA     MAIN_LOOP
000010EC                           128      
000010EC                           129  ;; print nops
000010EC                           130  PRINT_NOPS_TEST
000010EC  103C 000F                131      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
000010F0  143C 0010                132      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
000010F4                           133      * PRINT THE CURRENT ADDRESS
000010F4  220E                     134      MOVE.L  A6,D1
000010F6  4E4F                     135      TRAP    #15
000010F8  4281                     136      CLR.L   D1          * clear D1 so that it holds just the data on the next print
000010FA                           137      
000010FA  43F9 00001161            138      LEA     COLON_SPACE,A1
00001100  103C 000E                139      MOVE.B  #14,D0
00001104  4E4F                     140      TRAP    #15
00001106                           141      
00001106  103C 0001                142      MOVE.B  #1,D0   * Print string, no CRLF
0000110A                           143      
0000110A                           144      
0000110A                           145      
0000110A                           146      
0000110A                           147  
0000110A                           148  ;; ~~~~~~~~BEGINNING OF PRINT LOOP~~~~~~~~   
0000110A                           149  PRINT_IT          ;; Placeholder for now; just prints all data between start and end
0000110A  43F9 00001209            150      LEA     PRINT_IT_STRING,A1
00001110  103C 000D                151      MOVE.B  #13,D0
00001114  4E4F                     152      TRAP    #15
00001116                           153      
00001116                           154  PRINT_IT_LOOP
00001116  103C 000F                155      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
0000111A  143C 0010                156      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
0000111E                           157      * PRINT THE CURRENT ADDRESS
0000111E  220E                     158      MOVE.L  A6,D1
00001120  4E4F                     159      TRAP    #15
00001122  4281                     160      CLR.L   D1          * clear D1 so that it holds just the data on the next print
00001124                           161      
00001124  43F9 00001161            162      LEA     COLON_SPACE,A1
0000112A  103C 000E                163      MOVE.B  #14,D0
0000112E  4E4F                     164      TRAP    #15
00001130                           165      
00001130  221E                     166      MOVE.L  (A6)+,D1    * move the data at the pointer into D1 and increment.
00001132  103C 000F                167      MOVE.B  #15,D0      * Trap task 15 to print a signed number in the base in D2
00001136  4E4F                     168      TRAP    #15
00001138                           169      
00001138                           170      * Print a new line
00001138  43F9 00001158            171      LEA     NEW_LINE,A1
0000113E  103C 000D                172      MOVE.B  #13,D0
00001142  4E4F                     173      TRAP    #15
00001144                           174      
00001144                           175      * Check if end address has been reached
00001144  BDCD                     176      CMP.L   A5,A6
00001146  6FCE                     177      BLE     PRINT_IT_LOOP
00001148                           178  ;; ~~~~~~~~END OF PRINT LOOP~~~~~~~~
00001148                           179  
00001148                           180  
00001148                           181      
00001148                           182      
00001148  43F9 0000115B            183      LEA     DONE_MSG,A1
0000114E  103C 000D                184      MOVE.B  #13,D0
00001152  4E4F                     185      TRAP    #15
00001154                           186  
00001154  FFFF FFFF                187      SIMHALT             ; halt simulator
00001158                           188  
00001158                           189  * Put variables and constants here
00001158                           190  
00001158                           191  *** ASCII constants used in the conversion loop. Subtract these from an ASCII character to get its
00001158                           192  *** real hex value (depending on whether it's a digit or a character).
00001158  =00000030                193  ASC_NUM_MIN     EQU     $30     * ASCII key for 0
00001158  =00000039                194  ASC_NUM_MAX     EQU     $39     * ASCII key for 9
00001158  =00000041                195  ASC_CHAR_MIN    EQU     $41     * ASCII key for A
00001158  =00000046                196  ASC_CHAR_MAX    EQU     $46     * ASCII key for F
00001158                           197  
00001158                           198  *** Message strings
00001158                           199      * Temporary; used for debugging and testing
00001158= 00 0D 0A                 200  NEW_LINE        DC.B    '',0,CR,LF
0000115B                           201      * Temporary; used for debugging and testing
0000115B= 44 6F 6E 65 2E 00        202  DONE_MSG        DC.B    'Done.',0
00001161                           203      * Temporary; used for debugging and testing
00001161= 3A 20 00                 204  COLON_SPACE     DC.B    ': ',0
00001164= 49 6E 76 61 6C 69 ...    205  INVALID_INPUT   DC.B    'Invalid input! Out of Range.',0
00001181= 49 6E 76 61 6C 69 ...    206  END_LTE_BEG     DC.B    'Invalid input! End address is less than or equal to start address.',0  
000011C4= 45 6E 74 65 72 20 ...    207  ADDR_PRMPT_STRT DC.B    'Enter a starting address in hex: $',0
000011E7= 45 6E 74 65 72 20 ...    208  ADDR_PRMPT_END  DC.B    'Enter an ending address in hex: $',0
00001209= 49 20 61 6D 20 61 ...    209  PRINT_IT_STRING DC.B    'I am a PRINT_IT string. It is printing time!',0
00001236= 00                       210  NULL_TERM       DC.B    '',0
00001237  =0000000A                211  LF              EQU      $0A
00001237  =0000000D                212  CR              EQU      $0D
00001237                           213  
00001238= 00000001                 214  buffer  DC.L    1
0000123C                           215  
0000123C  =00008000                216  DISM_CODE     EQU     $8000 * Where to write disassembled code
0000123C                           217      
0000123C  4E71                     218      NOP * Ensures that included file aligns on word boundary
0000123E                           219  
0000123E                           220  END_NOW
0000123E  43F8 115B                221      LEA     DONE_MSG,A1
00001242  103C 0001                222      MOVE.B  #1,D0
00001246  4E4F                     223      TRAP    #15
00001248                           224      *LEA     buffer,A1
00001248                           225      
00001248                           226      INCLUDE 'OP.X68'
00001248                           227  
00001248                           228  ;; ~*~*~*~*~*~*~*~BEGIN OPCODE MODULE~*~*~*~*~*~*~*~
00001248                           229  
00001248                           230  OP_DECODE
00001248  3A1E                     231      MOVE.W  (A6)+,D5     * Load the next opcode to decode into D5, incrementing
0000124A                           232      * NOTE: A6 now points at either the next opcode or imm. data for EA part
0000124A                           233      
0000124A                           234      * is it NOP?
0000124A  BA7C 4E71                235      CMP.W   #CODE_NOP,D5
0000124E  6700 0230                236      BEQ     DO_NOP      * After execution of this branch, will return to I/O
00001252                           237      
00001252                           238      * is it RTS?
00001252  BA7C 4E75                239      CMP.W   #CODE_RTS,D5
00001256  6700 023A                240      BEQ     DO_RTS      * After execution of this branch, will return to I/O
0000125A                           241      
0000125A                           242      ** Not NOP or RTS, check bit-by-bit to narrow down
0000125A                           243      
0000125A  0805 000F                244      BTST.L  #15,D5       * Test the most significant bit of the command
0000125E  6700 000C                245      BEQ     OXXX_BRA     * Branch to opcodes starting with zero     
00001262  6000 00FA                246      BRA     IXXX_BRA     * Branch to opcodes starting with a one  ******** COME BAK
00001266                           247     
00001266  6000 0218                248      BRA     DO_NOP
0000126A  4E75                     249      RTS * Return to I/O module (temporary; will go to EA module eventually)
0000126C                           250      
0000126C                           251  OXXX_BRA
0000126C  0805 000E                252      BTST.L  #14,D5      * Test the second bit 
00001270  6700 0006                253      BEQ     OOXX_BRA    * Branch to opcodes starting with 00
00001274  6000 0012                254      BRA     OIXX_BRA    * Branch to opcodes starting with 01   *** COME BAK
00001278                           255  
00001278                           256  OOXX_BRA
00001278  0805 000D                257      BTST.L  #13,D5          * Test the second bit 
0000127C  6700 0016                258      BEQ     OOOX_BRA        * Branch to opcodes starting with 000
00001280  6000 001E                259      BRA     OOIX_BRA        * Might be MOVE, MOVEA
00001284  6000 0254                260      BRA     PRINT_INVALID_MSG
00001288                           261  OIXX_BRA
00001288  0805 000D                262      BTST.L  #13,D5
0000128C  6700 008A                263      BEQ     OIOX_BRA            * CLR, JSR, MOVEM, LEA, ADDQ, SUBQ
00001290  6000 0092                264      BRA     OIIX_BRA            * BCC, OR MOVEQ
00001294                           265  OOOX_BRA
00001294  0805 000C                266      BTST.L  #12,D5              * Test the second bit 
00001298  6700 0012                267      BEQ     OOOO_BRA            * Decision for SUBI or ADDI
0000129C  6000 0028                268      BRA     OOOI_BRA            * MOVE and MOVEA (B)
000012A0                           269  OOIX_BRA
000012A0  0805 000C                270      BTST.L  #12,D5              * Test the second bit 
000012A4  6700 0032                271      BEQ     OOIO_BRA            * MOVE or MOVEA need to be handled here (W)
000012A8  6000 004E                272      BRA     OOII_BRA            * MOVE or MOVEA need to be handled here (L)
000012AC                           273  
000012AC                           274  OOOO_BRA                        * tests for ADDI or SUBI
000012AC  343C 0F00                275      MOVE.W  #ADDSUBI_MASK,D2   * Load mask for ADDI temporarily into register for AND operation
000012B0  C445                     276      AND.W   D5,D2               * AND with current opcode data and store into D2
000012B2  B47C 0600                277      CMP.W   #$0600,D2           * Result of mask should be 0060 if the code is ADDi
000012B6  6700 0138                278      BEQ     DO_ADDI     
000012BA  B47C 0400                279      CMP.W   #$0400,D2           * SUBI and ADDI  have the same bitmask.
000012BE  6700 0178                280      BEQ     DO_SUBI
000012C2  6000 0216                281      BRA     PRINT_INVALID_MSG
000012C6                           282  OOOI_BRA                        * MOVE and MOVEA need to be handled here (B)
000012C6  343C 3000                283      MOVE.W  #MOVE_MASK,D2
000012CA  C445                     284      AND.W   D5,D2
000012CC  B47C 1000                285      CMP.W   #$1000,D2           * is it a move byte?
000012D0  6700 0090                286      BEQ     DO_MOVE_B           
000012D4                           287  
000012D4  6000 0204                288      BRA     PRINT_INVALID_MSG   *neither MoveA or Move? BADDDD
000012D8                           289  OOIO_BRA                        * MOVE and MOVEA need to be handled here (W)
000012D8  343C 31C0                290      MOVE.W  #MOVEA_MASK,D2
000012DC  C445                     291      AND.W   D5,D2
000012DE  B47C 2040                292      CMP.W   #$2040,D2           * is it a moveA word?
000012E2  6700 0096                293      BEQ     DO_MOVEA_W          
000012E6                           294  
000012E6  343C 3000                295      MOVE.W  #MOVE_MASK,D2
000012EA  C445                     296      AND.W   D5,D2
000012EC  B47C 2000                297      CMP.W   #$2000,D2           * is it a move word?
000012F0  6700 009A                298      BEQ     DO_MOVE_W           
000012F4                           299  
000012F4  6000 01E4                300      BRA     PRINT_INVALID_MSG
000012F8                           301  OOII_BRA                        * MOVE and MOVEA need to be handled here (L)
000012F8  343C 31C0                302      MOVE.W  #MOVEA_MASK,D2
000012FC  C445                     303      AND.W   D5,D2
000012FE  B47C 3040                304      CMP.W   #$3040,D2           * is it a moveA long?
00001302  6700 00A0                305      BEQ     DO_MOVEA_L          
00001306                           306  
00001306  343C 3000                307      MOVE.W  #MOVE_MASK,D2
0000130A  C445                     308      AND.W   D5,D2
0000130C  B47C 3000                309      CMP.W   #$3000,D2           * is it a move long?
00001310  6700 00A4                310      BEQ     DO_MOVE_L           
00001314                           311  
00001314  6000 01C4                312      BRA     PRINT_INVALID_MSG
00001318                           313  OIOX_BRA
00001318  0805 000C                314      BTST.L  #12,D5
0000131C  6700 0012                315      BEQ     OIOO_BRA    * CLR, JSR, MOVEM, LEA   
00001320  6000 0128                316      BRA     DO_ADDQ     * ADDQ 
00001324                           317  OIIX_BRA
00001324                           318      *check for MOVEQ and BCC here, which is 0110 always. there is no 0111
00001324  0805 000C                319      BTST.L  #12,D5
00001328  6700 00FC                320      BEQ     DO_Bcc            * BCC happens here, have to narrow it down to which one!
0000132C  6000 0188                321      BRA     DO_MOVEQ   
00001330                           322  OIOO_BRA
00001330                           323      ** Test for JSR
00001330  343C 0FC0                324      MOVE.W  #JSR_MASK,D2 * Load mask temporarily into register for ANDing
00001334  C445                     325      AND.W   D5,D2        * AND with the current opcode data
00001336  B47C 0E80                326      CMP.W   #$0E80,D2    * Result of mask should be 0E80 if code is JSR
0000133A  6700 018C                327      BEQ     DO_JSR       *
0000133E                           328  
0000133E  343C 0F00                329      MOVE.W  #CLR_MASK,D2
00001342  C445                     330      AND.W   D5,D2
00001344  B47C 0200                331      CMP.W   #$0200,D2              * IS IT CLR?
00001348  6700 0112                332      BEQ     DO_CLR
0000134C                           333  
0000134C  343C 01C0                334      MOVE.W  #LEA_MASK,D2
00001350  C445                     335      AND     D5,D2
00001352  B47C 01C0                336      CMP.W   #$01C0,D2              *EQUAL TO LEA?
00001356  6700 0116                337      BEQ.W   DO_LEA
0000135A  6000 0190                338      BRA     PRINT_OIOO_ERROR       * if not RTS, not JSR, CLR, or LEA, then its invalid. 
0000135E                           339  
0000135E                           340  IXXX_BRA
0000135E  6000 019E                341      BRA     PRINT_COME_BACK_MSG   * temporary until further development of right branch
00001362                           342      
00001362                           343  DO_MOVE_B
00001362  47F9 000015EA            344      LEA     S_MOVE_B,A3
00001368  1E3C 002A                345      MOVE.B  #$2A,D7         * for now, temporarily calling this mnemonic number 2, section a (which is a byte)
0000136C  4EB9 00001510            346      JSR     WRITE
00001372  4EB9 000016BC            347      JSR     MOVE_EA
00001378  4E75                     348      RTS
0000137A                           349  DO_MOVEA_W
0000137A  47F9 000015FA            350      LEA     S_MOVEA_W,A3
00001380  1E3C 003B                351      MOVE.B  #$3B,D7         * for now, temporarily calling this mnemonic number 3, section b (which is a word)
00001384                           352      ** Eventually, EA Module will be called here
00001384  4EB9 00001510            353      JSR     WRITE
0000138A  4E75                     354      RTS
0000138C                           355  DO_MOVE_W
0000138C  47F9 0000160A            356      LEA     S_MOVE_W,A3
00001392  1E3C 002B                357      MOVE.B  #$2B,D7         * for now, temporarily calling this mnemonic number 2, section b (which is a word)
00001396  4EB9 00001510            358      JSR     WRITE
0000139C  4EB9 000016BC            359      JSR     MOVE_EA
000013A2  4E75                     360      RTS
000013A4                           361  DO_MOVEA_L
000013A4  47F9 0000161A            362      LEA     S_MOVEA_L,A3
000013AA  1E3C 003C                363      MOVE.B  #$3C,D7         * for now, temporarily calling this mnemonic number 3, section c (which is a long)
000013AE                           364      ** Eventually, EA Module will be called here
000013AE  4EB9 00001510            365      JSR     WRITE
000013B4  4E75                     366      RTS
000013B6                           367  DO_MOVE_L
000013B6  47F9 0000162A            368      LEA     S_MOVE_L,A3
000013BC  1E3C 002C                369      MOVE.B  #$2C,D7         * for now, temporarily calling this mnemonic number 2, section c (which is a long)
000013C0  4EB9 00001510            370      JSR     WRITE
000013C6  4EB9 000016BC            371      JSR     MOVE_EA
000013CC  4E75                     372      RTS
000013CE                           373  
000013CE                           374  DO_BCC_CASE
000013CE  343C 0F00                375      MOVE.W  #Bcc_MASK,D2
000013D2  C445                     376      AND     D5,D2
000013D4  B47C 0E00                377      CMP.W   #$0E00,D2                * Is it BGT?
000013D8  6700 0028                378      BEQ.W   DO_BGT
000013DC                           379      
000013DC  B47C 0F00                380      CMP.W   #$0F00,D2                * Is it BLE?
000013E0  6700 0032                381      BEQ.W   DO_BLE
000013E4                           382  
000013E4  B47C 0400                383      CMP.W   #$0400,D2                * Is it BCC?
000013E8  6700 003C                384      BEQ.W   DO_BCC
000013EC                           385  
000013EC  6000 00EC                386      BRA     PRINT_INVALID_MSG        * none of these options? not required or invalid
000013F0                           387  
000013F0                           388  DO_ADDI
000013F0  47F9 0000156A            389      LEA     S_ADDI,A3
000013F6  1E3C 0008                390      MOVE.B  #8,D7
000013FA                           391      ** Eventually, EA Module will be called here
000013FA  4EB9 00001510            392      JSR     WRITE
00001400  4E75                     393      RTS
00001402                           394  DO_BGT
00001402  47F9 000015BA            395      LEA     S_BGT,A3
00001408  1E3C 001A                396      MOVE.B  #26,D7
0000140C                           397      ** Eventually, EA Module will be called here
0000140C  4EB9 00001510            398      JSR     WRITE
00001412  4E75                     399      RTS
00001414                           400  DO_BLE
00001414  47F9 000015CA            401      LEA     S_BLE,A3
0000141A  1E3C 001B                402      MOVE.B  #27,D7
0000141E                           403      ** Eventually, EA Module will be called here
0000141E  4EB9 00001510            404      JSR     WRITE
00001424  4E75                     405      RTS
00001426                           406  DO_BCC
00001426  47F9 000015DA            407      LEA     S_BCC,A3
0000142C  1E3C 001C                408      MOVE.B  #28,D7
00001430                           409      ** Eventually, EA Module will be called here
00001430  4EB9 00001510            410      JSR     WRITE
00001436  4E75                     411      RTS
00001438                           412  DO_SUBI
00001438  47F9 0000157A            413      LEA     S_SUBI,A3
0000143E  1E3C 000B                414      MOVE.B  #11,D7
00001442                           415      ** Eventually, EA Module will be called here
00001442  4EB9 00001510            416      JSR     WRITE
00001448  4E75                     417      RTS
0000144A                           418  DO_ADDQ
0000144A                           419      *Check for full opcode for 11 and onwards. if invalid, print the message
0000144A  47F9 0000155A            420      LEA     S_ADDQ,A3
00001450  1E3C 0009                421      MOVE.B  #9,D7
00001454                           422      ** Eventually, EA Module will be called here
00001454  4EB9 00001510            423      JSR     WRITE
0000145A  4E75                     424      RTS
0000145C                           425  DO_CLR
0000145C  47F9 0000158A            426      LEA     S_CLR,A3
00001462  1E3C 0010                427      MOVE.B  #16,D7
00001466                           428      ** Eventually, EA Module will be called here
00001466  4EB9 00001510            429      JSR     WRITE
0000146C  4E75                     430      RTS
0000146E                           431  DO_LEA
0000146E  47F9 0000159A            432      LEA     S_LEA,A3    * Load the NOP string into A3 for WRITE subroutine
00001474  1E3C 000F                433      MOVE.B  #15,D7       * Store key for op code for EA module
00001478                           434      ** Eventually, EA Module will be called here
00001478  4EB9 00001510            435      JSR     WRITE       * Jump to WRITE subroutine
0000147E  4E75                     436      RTS                 * Return to I/O module 
00001480                           437  DO_NOP
00001480  47F9 0000151A            438      LEA     S_NOP,A3    * Load the NOP string into A3 for WRITE subroutine
00001486  1E3C 0001                439      MOVE.B  #1,D7       * Store key for op code for EA module
0000148A                           440      ** Eventually, EA Module will be called here
0000148A  4EB9 00001510            441      JSR     WRITE       * Jump to WRITE subroutine
00001490  4E75                     442      RTS                 * Return to I/O module 
00001492                           443  DO_RTS
00001492  47F9 0000152A            444      LEA     S_RTS,A3    * Load the RTS string into A3 for WRITE subroutine
00001498  1E3C 001E                445      MOVE.B  #30,D7      * Store key for op code for EA module
0000149C                           446      ** Eventually, EA Module will be called here
0000149C  4EB9 00001510            447      JSR     WRITE       * Jump to WRITE subroutine
000014A2  4E75                     448      RTS                 * Return to the I/O module bra op_decode  
000014A4                           449  DO_MOVE
000014A4  47F9 0000153A            450      LEA     S_MOVE,A3
000014AA  1E3C 0002                451      MOVE.B  #2,D7
000014AE                           452      ** Eventually, EA Module will be called here
000014AE  4EB9 00001510            453      JSR     WRITE
000014B4  4E75                     454      RTS
000014B6                           455  DO_MOVEQ
000014B6  47F9 000015AA            456      LEA     S_MOVEQ,A3
000014BC  1E3C 0004                457      MOVE.B  #4,D7
000014C0  4EB9 00001510            458      JSR     WRITE
000014C6  4E75                     459      RTS
000014C8                           460  DO_JSR
000014C8  47F9 0000154A            461      LEA     S_JSR,A3
000014CE  1E3C 001B                462      MOVE.B  #27,D7
000014D2                           463      ** Eventually, NOCK will be called here
000014D2  4EB9 00001510            464      JSR     WRITE
000014D8  4E75                     465      RTS
000014DA                           466  PRINT_INVALID_MSG
000014DA  47F9 0000163A            467      LEA     INVALID,A3
000014E0  1E3C 0000                468      MOVE.B  #0,D7
000014E4                           469      ** Eventually, NOCK will be called here
000014E4  4EB9 00001510            470      JSR     WRITE
000014EA  4E75                     471      RTS
000014EC                           472  PRINT_OIOO_ERROR
000014EC  47F9 00001689            473      LEA     BAD_OIOO,A3
000014F2  1E3C 0000                474      MOVE.B  #0,D7
000014F6                           475      ** Eventually, NOCK will be called here
000014F6  4EB9 00001510            476      JSR     WRITE
000014FC  4E75                     477      RTS
000014FE                           478  PRINT_COME_BACK_MSG
000014FE  47F9 00001666            479      LEA     COMEBK,A3
00001504  1E3C 0000                480      MOVE.B  #0,D7
00001508                           481      ** Eventually, NOCK will be called here
00001508  4EB9 00001510            482      JSR     WRITE
0000150E  4E75                     483      RTS
00001510                           484  WRITE   * Writes string pointed to by A3 to memory pointed to by A1
00001510                           485      *MOVEA.L A4,A1     * Save the position of A4 before writing (for I/0)
00001510                           486  WRITE_LOOP
00001510  18DB                     487      MOVE.B  (A3)+,(A4)+     * Write one byte and increment
00001512  0C13 0000                488      CMP.B   #0,(A3)         * Are we at the null terminator?
00001516  66F8                     489      BNE     WRITE_LOOP      * If not, keep going
00001518                           490      *MOVE.B  #$2C,(A4)+     * Write the null terminator before exiting
00001518  4E75                     491      RTS                     * Executes once null terminator was reached
0000151A                           492      
0000151A                           493  ;; ~~~~~~~~STRING CONSTANTS~~~~~~~~
0000151A                           494  
0000151A  =00004E71                495  CODE_NOP    EQU     $4E71
0000151A  =00004E75                496  CODE_RTS    EQU     $4E75
0000151A                           497  
0000151A  =00002000                498  A4_PREV     SET     $2000
0000151A                           499  
0000151A= 4E 4F 50 20 20 20 ...    500  S_NOP       DC.B    'NOP            ',0
0000152A= 52 54 53 20 20 20 ...    501  S_RTS       DC.B    'RTS            ',0
0000153A= 4D 4F 56 45 20 20 ...    502  S_MOVE      DC.B    'MOVE           ',0
0000154A= 4A 53 52 20 20 20 ...    503  S_JSR       DC.B    'JSR            ',0
0000155A= 41 44 44 51 20 20 ...    504  S_ADDQ      DC.B    'ADDQ           ',0
0000156A= 41 44 44 49 20 20 ...    505  S_ADDI      DC.B    'ADDI           ',0
0000157A= 53 55 42 49 20 20 ...    506  S_SUBI      DC.B    'SUBI           ',0
0000158A= 43 4C 52 20 20 20 ...    507  S_CLR       DC.B    'CLR            ',0
0000159A= 4C 45 41 20 20 20 ...    508  S_LEA       DC.B    'LEA            ',0
000015AA= 4D 4F 56 45 51 20 ...    509  S_MOVEQ     DC.B    'MOVEQ          ',0
000015BA= 42 47 54 20 20 20 ...    510  S_BGT       DC.B    'BGT            ',0
000015CA= 42 4C 45 20 20 20 ...    511  S_BLE       DC.B    'BLE            ',0
000015DA= 42 43 43 20 20 20 ...    512  S_BCC       DC.B    'BCC            ',0
000015EA= 4D 4F 56 45 2E 42 ...    513  S_MOVE_B    DC.B    'MOVE.B         ',0
000015FA= 4D 4F 56 45 41 2E ...    514  S_MOVEA_W   DC.B    'MOVEA.W        ',0
0000160A= 4D 4F 56 45 2E 57 ...    515  S_MOVE_W    DC.B    'MOVE.W         ',0
0000161A= 4D 4F 56 45 41 2E ...    516  S_MOVEA_L   DC.B    'MOVEA.L        ',0
0000162A= 4D 4F 56 45 2E 4C ...    517  S_MOVE_L    DC.B    'MOVE.L         ',0
0000163A                           518  
0000163A                           519  
0000163A= 49 4E 56 41 4C 49 ...    520  INVALID     DC.B    'INVALID OPCODE. LETS FIX THIS MESSAGE LATER',0
00001666= 43 6F 6D 65 20 62 ...    521  COMEBK      DC.B    'Come back to me pls dont forget me',0 
00001689= 42 61 64 20 4F 49 ...    522  BAD_OIOO    DC.B    'Bad OIOO maybe not JSR,RTS,CLR,LEA.. who knows.',0
000016B9                           523  
000016B9  =00000FC0                524  JSR_MASK        EQU     %0000111111000000
000016B9  =00000F00                525  ADDSUBI_MASK    EQU     %0000111100000000       ** come back and fix this to be the same but diferent comparisons 
000016B9  =00000000                526  BYTE_MASK       EQU     %0000000000000000       * Not sure if this is needed
000016B9  =00000040                527  WORD_MASK       EQU     %0000000001000000       * not sure if this is needed
000016B9  =00000080                528  LONG_MASK       EQU     %0000000010000000       * not sure if this is needed
000016B9  =00000F00                529  CLR_MASK        EQU     %0000111100000000
000016B9  =000001C0                530  LEA_MASK        EQU     %0000000111000000
000016B9  =00000F00                531  Bcc_MASK        EQU     %0000111100000000
000016B9                           532  
000016B9  =000031C0                533  MOVEA_MASK      EQU     %0011000111000000
000016B9  =00003000                534  MOVE_MASK       EQU     %0011000000000000
000016B9                           535  ;; ~*~*~*~*~*~*~*~END OPCODE MODULE~*~*~*~*~*~*~*~
000016B9                           536  
000016B9                           537  
000016B9                           538  
000016B9                           539  -------------------- end include --------------------
000016B9                           540      
000016BA  4E71                     541      NOP * Ensures that included file aligns on word boundary
000016BC                           542      
000016BC                           543      INCLUDE 'EA.X68'
000016BC                           544  
000016BC                           545  
000016BC                           546  ;;;;;;;;;;; HEY HELLO HEY -----> WRITE A NULL TERM AT END OF DECODING A CMD!!! <------
000016BC                           547  
000016BC                           548  ;; ~*~*~*~*~*~*~*~BEGIN EA MODULE~*~*~*~*~*~*~*~
000016BC                           549  
000016BC                           550  
000016BC                           551  
000016BC                           552  
000016BC                           553  
000016BC                           554  ;; PROBABLY REMOVE THIS WRITE SR
000016BC                           555  
000016BC                           556  MOVE_EA
000016BC                           557  
000016BC                           558  ;; *~*~*~*~*~*~*~ pSeUdOcOdE ~*~*~*~*~*~*~* ;;
000016BC                           559      * 1.) Mask 3 LSB into D6 (reg #)
000016BC                           560      * 2.) ROR 3 bits
000016BC                           561      * 3.) Mask 3 LSB into D0 (mode #)
000016BC                           562      * 4.) Call mode-specific buffer writer (DO_MODE -> write_mode_x)
000016BC                           563  ;; NOTES: there will be one mode-specific buffer writer for each mode.
000016BC                           564  ;; The routine will write mode-specific strings to the buffer in addition to
000016BC                           565  ;; the register number (converted to ASCII). Use A3 and A4 to do this.
000016BC                           566      * 5.) Write a comma
000016BC                           567      * 6.) ROR 3 bits
000016BC                           568      * 7.) Mask 3 LSB into D0 (mode #)
000016BC                           569      * 8.) ROR 3 bits
000016BC                           570      * 9.) Mask 3 LSB into D6 (reg #)
000016BC                           571      * 10.) Call mode-specific buffer writer
000016BC                           572      * 11.) Return to I/O module
000016BC                           573      
000016BC                           574  
000016BC  2C05                     575      MOVE.L  D5,D6               * D6 will be masked to hold only 3 LSB (reg #)
000016BE  CC7C 0007                576      AND.W   #THREE_LSB_MASK,D6  * D6 now holds source register #
000016C2  E65D                     577      ROR.W   #3,D5               * rotate by 3 bits. mode should now be 3 LSB
000016C4  2005                     578      MOVE.L  D5,D0               * D0 will hold the mode
000016C6  C07C 0007                579      AND.W   #THREE_LSB_MASK,D0  * D0 now holds source mode code
000016CA  4EB9 000016EC            580      JSR     DO_MODE             * Get source mode decoded and written to buffer
000016D0                           581      
000016D0                           582      ** CURRENT BUFFER STATE: MOVE.x         Xn
000016D0                           583      
000016D0  18FC 002C                584      MOVE.B  #',',(A4)+           * Write the comma between EA modes
000016D4  E65D                     585      ROR.W   #3,D5               * dest mode is now 3 LSB of D5
000016D6  2005                     586      MOVE.L  D5,D0               * Copy new rotated word into D0 for masking
000016D8  C07C 0007                587      AND.W   #THREE_LSB_MASK,D0  * D0 now holds dest mode code
000016DC  E65D                     588      ROR.W   #3,D5               * source register is now 3 LSB of D5
000016DE  2C05                     589      MOVE.L  D5,D6               * Copy new rotated word into D6 for masking
000016E0  CC7C 0007                590      AND.W   #THREE_LSB_MASK,D6  * mask source register into D6
000016E4  4EB9 000016EC            591      JSR     DO_MODE             * Get dest mode decoded and written to buffer
000016EA                           592      
000016EA                           593      ** FINAL BUFFER STATE: MOVE.x         Xn,Xn
000016EA                           594      
000016EA  4E75                     595      RTS
000016EC                           596      
000016EC                           597      
000016EC                           598      
000016EC                           599  ;; Finds the mode stored in D6 and branches to appropriate SR to write to the buffer
000016EC                           600  DO_MODE
000016EC  B03C 0000                601      CMP.B   #00,D0      ** Mode 0 - Data Register Direct
000016F0  6700 0024                602      BEQ     DR_DIRECT
000016F4                           603      
000016F4  B03C 0001                604      CMP.B   #01,D0      ** Mode 1 - Address Register Direct
000016F8  6700 0028                605      BEQ     AR_DIRECT   
000016FC                           606      
000016FC  B03C 0002                607      CMP.B   #02,D0      ** Mode 2 - Address Register Indirect
00001700  6700 0020                608      BEQ     AR_INDIRECT
00001704                           609      
00001704  B03C 0003                610      CMP.B   #03,D0      ** Mode 3 - Address Register Indirect w/ Post-increment
00001708  6700 0018                611      BEQ     AR_POSTINC
0000170C                           612      
0000170C  B03C 0004                613      CMP.B   #04,D0      ** Mode 4 - Address Register Indirect w/ Pre-decrement
00001710  6700 0010                614      BEQ     AR_PREDEC
00001714                           615      
00001714                           616      ** HERE: check for non-required EA modes (101, 110, 111 w/ 010 in Xn, 111 w/ 011 in Xn)
00001714                           617      ** if found, branch to "unsupported EA mode" branch
00001714                           618      
00001714  4E75                     619      RTS
00001716                           620  
00001716                           621  
00001716                           622  DR_DIRECT   *** Mode 0
00001716  18FC 0044                623      MOVE.B  #'D',(A4)+   * Write D to the buffer
0000171A  0606 0030                624      ADDI.B  #$30,D6     * Add $30 to the register number to convert to ASCII
0000171E  18C6                     625      MOVE.B  D6,(A4)+    * Write the ASCII-converted number to the buffer
00001720  4E75                     626      RTS
00001722                           627  
00001722                           628  AR_DIRECT   *** Mode 1
00001722                           629      
00001722                           630  
00001722                           631  AR_INDIRECT *** Mode 2
00001722                           632      * WRITE (A
00001722                           633      * WRITE NUMBER IN D6
00001722                           634      * WRITE )
00001722                           635  
00001722                           636  AR_POSTINC  *** Mode 3
00001722                           637      * WRITE (A
00001722                           638      * WRITE NUMBER IN D6
00001722                           639      * WRITE )+
00001722                           640      
00001722                           641  AR_PREDEC   *** Mode 4
00001722                           642      * WRITE -(A
00001722                           643      * WRITE NUMBER IN D6
00001722                           644      * WRITE )
00001722                           645  
00001722                           646  IMM_DATA
00001722                           647      * HOW TO DO THIS?
00001722                           648  
00001722                           649  ABS_LONG
00001722                           650      * GET LONG FROM (A6)+
00001722                           651      * WRITE $
00001722                           652      * WRITE DATA GOT FROM A6
00001722                           653  
00001722                           654  ABS_WORD
00001722                           655      * GET WORD FROM (A6)+
00001722                           656      * WRITE $
00001722                           657      * WRITE DATA GOT FROM A6
00001722                           658      
00001722                           659  
00001722  =00000007                660  THREE_LSB_MASK  EQU     %0000000000000111
00001722                           661  
00001722                           662  ;; ~*~*~*~*~*~*~*~END EA MODULE~*~*~*~*~*~*~*~
00001722                           663  
00001722                           664      END    START        ; last line of source
00001722                           665  -------------------- end include --------------------

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A4_PREV             2000
ABS_LONG            1722
ABS_WORD            1722
ADDR_PRMPT_END      11E7
ADDR_PRMPT_STRT     11C4
ADDSUBI_MASK        F00
AR_DIRECT           1722
AR_INDIRECT         1722
AR_POSTINC          1722
AR_PREDEC           1722
ASC_CHAR_MAX        46
ASC_CHAR_MIN        41
ASC_NUM_MAX         39
ASC_NUM_MIN         30
ASC_TO_CHAR         1098
ASC_TO_NUM          108E
BAD_OIOO            1689
BCC_MASK            F00
BUFFER              1238
BYTE_MASK           0
CHECK_CHAR_MAX      1082
CHECK_CHAR_MIN      1076
CHECK_NUM_MAX       1068
CHECK_NUM_MIN       105C
CLR_MASK            F00
CODE_NOP            4E71
CODE_RTS            4E75
COLON_SPACE         1161
COMEBK              1666
CONVERSION_LOOP     105A
CR                  D
DISM_CODE           8000
DONE_MSG            115B
DO_ADDI             13F0
DO_ADDQ             144A
DO_BCC              1426
DO_BCC_CASE         13CE
DO_BGT              1402
DO_BLE              1414
DO_CLR              145C
DO_JSR              14C8
DO_LEA              146E
DO_MODE             16EC
DO_MOVE             14A4
DO_MOVEA_L          13A4
DO_MOVEA_W          137A
DO_MOVEQ            14B6
DO_MOVE_B           1362
DO_MOVE_L           13B6
DO_MOVE_W           138C
DO_NOP              1480
DO_RTS              1492
DO_SUBI             1438
DR_DIRECT           1716
END_LTE_BEG         1181
END_NOW             123E
ERROR_END_LTE_BEG   10BE
ERROR_INV_INP       10AE
IMM_DATA            1722
INVALID             163A
INVALID_INPUT       1164
IXXX_BRA            135E
JSR_MASK            FC0
LEA_MASK            1C0
LF                  A
LONG_MASK           80
MAIN_LOOP           10CE
MOVEA_MASK          31C0
MOVE_EA             16BC
MOVE_MASK           3000
NEW_LINE            1158
NULL_TERM           1236
OIIX_BRA            1324
OIOO_BRA            1330
OIOX_BRA            1318
OIXX_BRA            1288
OOII_BRA            12F8
OOIO_BRA            12D8
OOIX_BRA            12A0
OOOI_BRA            12C6
OOOO_BRA            12AC
OOOX_BRA            1294
OOXX_BRA            1278
OP_DECODE           1248
OXXX_BRA            126C
PRINT_COME_BACK_MSG  14FE
PRINT_INVALID_MSG   14DA
PRINT_IT            110A
PRINT_IT_LOOP       1116
PRINT_IT_STRING     1209
PRINT_LOOP          10DA
PRINT_NOPS_TEST     10EC
PRINT_OIOO_ERROR    14EC
SHIFTS              10A2
START               1000
S_ADDI              156A
S_ADDQ              155A
S_BCC               15DA
S_BGT               15BA
S_BLE               15CA
S_CLR               158A
S_JSR               154A
S_LEA               159A
S_MOVE              153A
S_MOVEA_L           161A
S_MOVEA_W           15FA
S_MOVEQ             15AA
S_MOVE_B            15EA
S_MOVE_L            162A
S_MOVE_W            160A
S_NOP               151A
S_RTS               152A
S_SUBI              157A
THREE_LSB_MASK      7
WORD_MASK           40
WRITE               1510
WRITE_LOOP          1510
