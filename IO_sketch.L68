00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/19/2018 11:30:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler I/O 
00000000                             3  * Written by :  touCANs
00000000                             4  * Date       :  5/1/18 - 
00000000                             5  * Description:  I/O functionality for the disassembler 
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000  287C 00008000             11      MOVEA.L #DISM_CODE,A4
00001006                            12      
00001006  43F9 000011BE             13      LEA     ADDR_PRMPT_STRT,A1
0000100C  103C 000E                 14      MOVE.B  #14,D0
00001010  4E4F                      15      TRAP    #15
00001012                            16  
00001012  43F9 00001230             17      LEA     buffer,A1       * Load buffer's effective address into A1
00001018  103C 0002                 18      MOVE.B  #2,D0           * get the starting address from the user as a string
0000101C                            19      
0000101C  4E4F                      20      TRAP    #15         
0000101E                            21      
0000101E                            22  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
0000101E  B27C 0004                 23      CMP     #4,D1           * minimum of a word for the address
00001022  6D00 008E                 24      BLT     ERROR_INV_INP   * invalid start address  
00001026                            25      
00001026  4EB9 0000105E             26      JSR     CONVERSION_LOOP * convert the starting address
0000102C                            27      
0000102C                            28  *** FULL STARTING ADDRESS HAS BEEN CONVERTED, STORE IN A6 AND GET ENDING ADDRESSS
0000102C  2C42                      29      MOVEA.L D2,A6           * move converted addr to A6 (A6 acts as iterator while disassembling)
0000102E  4282                      30      CLR.L   D2              * clear register D2 in preparation to hold the converted end address
00001030  4284                      31      CLR.L   D4              * clear register D4 to start the counter at 0 again
00001032                            32      
00001032  43F9 000011E1             33      LEA     ADDR_PRMPT_END,A1
00001038  103C 000E                 34      MOVE.B  #14,D0
0000103C  4E4F                      35      TRAP    #15
0000103E                            36      
0000103E  103C 0002                 37      MOVE.B  #2,D0           * get the ending address from the user as a string
00001042  4E4F                      38      TRAP    #15
00001044                            39      
00001044                            40  *** Need to first check if D1 is a valid size of minimum 4 (user entered at least 4 hexa bits)
00001044  B27C 0004                 41      CMP     #4,D1           * minimum of a word for the address
00001048  6D00 0068                 42      BLT     ERROR_INV_INP   * invalid end address
0000104C                            43      
0000104C  4EB9 0000105E             44      JSR     CONVERSION_LOOP * convert the ending address
00001052  2A42                      45      MOVEA.L D2,A5           * move converted addr to A5 (compare A6 to A5 to know when to stop)
00001054  BDCD                      46      CMPA.L  A5,A6           * check if beginning address is >= end address. If so, display error
00001056  6C00 006A                 47      BGE     ERROR_END_LTE_BEG
0000105A  6000 0076                 48      BRA     MAIN_LOOP       * skip past the CONVERSION_LOOP subroutine to continue with the program
0000105E                            49      
0000105E                            50  
0000105E                            51  
0000105E                            52  *    ADDI.B  #1,D4           * offset our counter to start at 1
0000105E                            53  
0000105E                            54  
0000105E                            55  ;; ~~~~~~~~BEGINNING OF CONVERSION SUBROUTINE~~~~~~~~
0000105E                            56  CONVERSION_LOOP       
0000105E  1619                      57      MOVE.B  (A1)+,D3        * store the next thingy B
00001060                            58  *** Need to check for proper hex conversion 
00001060                            59  
00001060                            60  CHECK_NUM_MIN     ;; Checks if number is >= 30 (0) in ASCII
00001060  B67C 0030                 61      CMP     #ASC_NUM_MIN,D3 * Range of ASCII numbers: (2F >= 3A)[2F,3A] then subtract 30    
00001064  6C00 0006                 62      BGE     CHECK_NUM_MAX   * check if it's in range for x > 2F
00001068  6000 0048                 63      BRA     ERROR_INV_INP   * First condition not met, go to bad input error 
0000106C                            64      
0000106C                            65  CHECK_NUM_MAX     ;; Checks if number is <= 39 (9) in ASCII
0000106C  B67C 0039                 66      CMP     #ASC_NUM_MAX,D3
00001070  6F00 0020                 67      BLE     ASC_TO_NUM      * If condition for the range was met, do the math
00001074  4EF9 0000107A             68      JMP     CHECK_CHAR_MIN  * Second condition was not met, check if a character
0000107A                            69      
0000107A                            70  CHECK_CHAR_MIN    ;; Checks if number is >= 41 (A) in ASCII
0000107A  B67C 0041                 71      CMP     #ASC_CHAR_MIN,D3
0000107E  6C00 0006                 72      BGE     CHECK_CHAR_MAX  
00001082  6000 002E                 73      BRA     ERROR_INV_INP   * First condition not met, D3 < 41 = symbols. Go to bad input error
00001086                            74      
00001086                            75  CHECK_CHAR_MAX    ;; Checks if number is <= 46 (F) in ASCII
00001086  B67C 0046                 76      CMP     #ASC_CHAR_MAX,D3
0000108A  6F00 0010                 77      BLE     ASC_TO_CHAR     * Condition was met for A-F     
0000108E  6000 0022                 78      BRA     ERROR_INV_INP   * Greater than 46 = out of 16-bit system
00001092                            79      
00001092                            80  ASC_TO_NUM        ;; Converts a string digit into a hex value
00001092  0403 0030                 81      SUBI.B  #$30,D3
00001096  4EF9 000010A6             82      JMP     SHIFTS          * After this routine is finished, complete shifts/adds
0000109C                            83      
0000109C                            84  ASC_TO_CHAR       ;; Converts a string character into a hex value
0000109C  0403 0037                 85      SUBI.B  #$37,D3    
000010A0  4EF9 000010A6             86      JMP     SHIFTS          * Convert a string character into a hex value
000010A6                            87      
000010A6                            88  SHIFTS            ;; Shifts D2 left by four bits to make room for the newly converted hexabit
000010A6  E98A                      89      LSL.L   #4,D2           * Initial value in D2 shifted hexabit over to the left to make room   
000010A8  D403                      90      ADD.B   D3,D2           * Add modified value from D3 into D2.
000010AA                            91      
000010AA  5204                      92      ADD.B   #1,D4           * Increment counter by 1 
000010AC  B244                      93      CMP     D4,D1           * Check if we have already reached the end of the input. D4 = counter
000010AE  66AE                      94      BNE     CONVERSION_LOOP * Continue back to the loop if D4 != D1  
000010B0  4E75                      95      RTS
000010B2                            96  ;; ~~~~~~~~END OF CONVERSION SUBROUTINE~~~~~~~~
000010B2                            97      
000010B2                            98      
000010B2                            99      
000010B2                           100  ERROR_INV_INP ;; Prints the INVALID_INPUT error message to the console
000010B2  43F9 0000115E            101      LEA     INVALID_INPUT,A1
000010B8  103C 000D                102      MOVE.B  #13,D0
000010BC  4E4F                     103      TRAP    #15
000010BE  6000 0176                104      BRA     END_NOW
000010C2                           105      
000010C2                           106  ERROR_END_LTE_BEG ;; Prints the END_LTE_BEG (end <= to beginning) error message to the console.
000010C2  43F9 0000117B            107      LEA     END_LTE_BEG,A1
000010C8  103C 000D                108      MOVE.B  #13,D0
000010CC  4E4F                     109      TRAP    #15
000010CE  6000 0166                110      BRA     END_NOW
000010D2                           111    
000010D2                           112    
000010D2                           113  MAIN_LOOP
000010D2                           114      *BRA     END_NOW
000010D2  BDCD                     115      CMPA.L  A5,A6
000010D4  6C00 0160                116      BGE     END_NOW * End program
000010D8                           117      *MOVE.W  A6,D0   * Copy A6 location to restore after jump to SR
000010D8  4EB9 00001244            118      JSR     OP_DECODE
000010DE                           119      
000010DE                           120  PRINT_LOOP ;; Print the most recently decoded line
000010DE  103C 000D                121      MOVE.B  #13,D0
000010E2  4E4F                     122      TRAP    #15
000010E4  60EC                     123      BRA     MAIN_LOOP
000010E6                           124      
000010E6                           125      
000010E6                           126      
000010E6                           127    
000010E6                           128  ;; print nops
000010E6                           129  PRINT_NOPS_TEST
000010E6  103C 000F                130      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
000010EA  143C 0010                131      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
000010EE                           132      * PRINT THE CURRENT ADDRESS
000010EE  220E                     133      MOVE.L  A6,D1
000010F0  4E4F                     134      TRAP    #15
000010F2  4281                     135      CLR.L   D1          * clear D1 so that it holds just the data on the next print
000010F4                           136      
000010F4  43F9 0000115B            137      LEA     COLON_SPACE,A1
000010FA  103C 000E                138      MOVE.B  #14,D0
000010FE  4E4F                     139      TRAP    #15
00001100                           140      
00001100  103C 0001                141      MOVE.B  #1,D0   * Print string, no CRLF
00001104                           142      
00001104                           143      
00001104                           144      
00001104                           145      
00001104                           146  
00001104                           147  ;; ~~~~~~~~BEGINNING OF PRINT LOOP~~~~~~~~   
00001104                           148  PRINT_IT          ;; Placeholder for now; just prints all data between start and end
00001104  43F9 00001203            149      LEA     PRINT_IT_STRING,A1
0000110A  103C 000D                150      MOVE.B  #13,D0
0000110E  4E4F                     151      TRAP    #15
00001110                           152      
00001110                           153  PRINT_IT_LOOP
00001110  103C 000F                154      MOVE.B  #15,D0  * Trap task 15 to print a signed number in the base in D2
00001114  143C 0010                155      MOVE.B  #16,D2  * Base 16 for the next two TRAPs
00001118                           156      * PRINT THE CURRENT ADDRESS
00001118  220E                     157      MOVE.L  A6,D1
0000111A  4E4F                     158      TRAP    #15
0000111C  4281                     159      CLR.L   D1          * clear D1 so that it holds just the data on the next print
0000111E                           160      
0000111E  43F9 0000115B            161      LEA     COLON_SPACE,A1
00001124  103C 000E                162      MOVE.B  #14,D0
00001128  4E4F                     163      TRAP    #15
0000112A                           164      
0000112A  221E                     165      MOVE.L  (A6)+,D1    * move the data at the pointer into D1 and increment.
0000112C  103C 000F                166      MOVE.B  #15,D0      * Trap task 15 to print a signed number in the base in D2
00001130  4E4F                     167      TRAP    #15
00001132                           168      
00001132                           169      * Print a new line
00001132  43F9 00001152            170      LEA     NEW_LINE,A1
00001138  103C 000D                171      MOVE.B  #13,D0
0000113C  4E4F                     172      TRAP    #15
0000113E                           173      
0000113E                           174      * Check if end address has been reached
0000113E  BDCD                     175      CMP.L   A5,A6
00001140  6FCE                     176      BLE     PRINT_IT_LOOP
00001142                           177  ;; ~~~~~~~~END OF PRINT LOOP~~~~~~~~
00001142                           178  
00001142                           179  
00001142                           180      
00001142                           181      
00001142  43F9 00001155            182      LEA     DONE_MSG,A1
00001148  103C 000D                183      MOVE.B  #13,D0
0000114C  4E4F                     184      TRAP    #15
0000114E                           185  
0000114E  FFFF FFFF                186      SIMHALT             ; halt simulator
00001152                           187  
00001152                           188  * Put variables and constants here
00001152                           189  
00001152                           190  *** ASCII constants used in the conversion loop. Subtract these from an ASCII character to get its
00001152                           191  *** real hex value (depending on whether it's a digit or a character).
00001152  =00000030                192  ASC_NUM_MIN     EQU     $30     * ASCII key for 0
00001152  =00000039                193  ASC_NUM_MAX     EQU     $39     * ASCII key for 9
00001152  =00000041                194  ASC_CHAR_MIN    EQU     $41     * ASCII key for A
00001152  =00000046                195  ASC_CHAR_MAX    EQU     $46     * ASCII key for F
00001152                           196  
00001152                           197  *** Message strings
00001152                           198      * Temporary; used for debugging and testing
00001152= 00 0D 0A                 199  NEW_LINE        DC.B    '',0,CR,LF
00001155                           200      * Temporary; used for debugging and testing
00001155= 44 6F 6E 65 2E 00        201  DONE_MSG        DC.B    'Done.',0
0000115B                           202      * Temporary; used for debugging and testing
0000115B= 3A 20 00                 203  COLON_SPACE     DC.B    ': ',0
0000115E= 49 6E 76 61 6C 69 ...    204  INVALID_INPUT   DC.B    'Invalid input! Out of Range.',0
0000117B= 49 6E 76 61 6C 69 ...    205  END_LTE_BEG     DC.B    'Invalid input! End address is less than or equal to start address.',0  
000011BE= 45 6E 74 65 72 20 ...    206  ADDR_PRMPT_STRT DC.B    'Enter a starting address in hex: $',0
000011E1= 45 6E 74 65 72 20 ...    207  ADDR_PRMPT_END  DC.B    'Enter an ending address in hex: $',0
00001203= 49 20 61 6D 20 61 ...    208  PRINT_IT_STRING DC.B    'I am a PRINT_IT string. It is printing time!',0
00001230  =0000000A                209  LF              EQU      $0A
00001230  =0000000D                210  CR              EQU      $0D
00001230                           211  
00001230= 00000001                 212  buffer  DC.L    1
00001234                           213  
00001234  =00008000                214  DISM_CODE     EQU     $8000 * Where to write disassembled code
00001234                           215      
00001234  4E71                     216      NOP
00001236                           217  
00001236                           218  END_NOW
00001236  43F8 1155                219      LEA     DONE_MSG,A1
0000123A  103C 0001                220      MOVE.B  #1,D0
0000123E  4E4F                     221      TRAP    #15
00001240  43F8 1230                222      LEA     buffer,A1
00001244                           223      
00001244                           224      INCLUDE 'OP.X68'
00001244                           225  
00001244                           226  ;; ~*~*~*~*~*~*~*~BEGIN OPCODE MODULE~*~*~*~*~*~*~*~
00001244                           227  
00001244                           228  OP_DECODE
00001244  3A1E                     229      MOVE.W  (A6)+,D5     * Load the next opcode to decode into D5, incrementing
00001246                           230      * NOTE: A6 now points at either the next opcode or imm. data for EA part
00001246                           231      
00001246                           232      * is it NOP?
00001246  BA7C 4E71                233      CMP.W   #CODE_NOP,D5
0000124A  6700 004E                234      BEQ     DO_NOP       * This will take it on back to the I/O module
0000124E                           235      
0000124E                           236      * is it RTS?
0000124E  BA7C 4E75                237      CMP.W   #CODE_RTS,D5
00001252  6700 0058                238      BEQ     DO_RTS       * This will take it on back to the I/O module
00001256                           239      
00001256                           240      
00001256                           241      ** Not NOP or RTS, check bit-by-bit to narrow down
00001256                           242      
00001256  0805 000F                243      BTST.L  #15,D5       * Test the most significant bit of the command
0000125A  6700 0008                244      BEQ     OXXX_BRA     * Branch to opcodes starting with zero     
0000125E                           245      * BRA     IXXX_BRA     * Branch to opcodes starting with a one  ******** COME BAK
0000125E                           246     
0000125E  6000 003A                247      BRA     DO_NOP
00001262  4E75                     248      RTS * Return to I/O module (temporary; will go to EA module eventually)
00001264                           249      
00001264                           250      
00001264                           251  ;; ~~~~~~~~BRANCHES FOR NARROWING OPCODE SELECTION~~~~~~~~
00001264                           252  OXXX_BRA
00001264  0805 000E                253      BTST.L  #14,D5      * Test the second bit 
00001268  6700 0002                254      BEQ     OOXX_BRA    * Branch to opcodes starting with 00
0000126C                           255      * BRA     OIXX_BRA    * Branch to opcodes starting with 01   *** COME BAK
0000126C                           256  
0000126C                           257  OOXX_BRA
0000126C  0805 000D                258      BTST.L  #13,D5      * Test the second bit 
00001270  6700 0002                259      BEQ     OOOX_BRA    * Branch to opcodes starting with 000
00001274                           260      * BRA     OIIX_BRA    * Branch to opcodes starting with 011   *** COME BAK
00001274                           261      
00001274                           262  OOOX_BRA
00001274  0805 000C                263      BTST.L  #12,D5      * Test the second bit 
00001278  6700 0002                264      BEQ     OOOO_BRA    * Decision for SUBI or ADDI
0000127C                           265      * BRA     OIII_BRA    * Branch to opcodes starting with 01   *** COME BAK
0000127C                           266  
0000127C                           267  OOOO_BRA                * tests for ADDI or SUBI
0000127C                           268  
0000127C                           269  OIXX_BRA
0000127C  0805 000D                270      BTST.L  #13,D5
00001280  6700 0002                271      BEQ     OIOX_BRA    * CLR, JSR, MOVEM, LEA, ADDQ, SUBQ
00001284                           272      
00001284                           273  OIOX_BRA
00001284  0805 000C                274      BTST.L  #12,D5
00001288  6700 0002                275      BEQ     OIOO_BRA    * CLR, JSR, MOVEM, LEA
0000128C                           276      
0000128C                           277  OIOO_BRA
0000128C                           278      ** Test for JSR
0000128C  343C 0E80                279      MOVE.W  #JSR_MASK,D2 * Load mask temporarily into register for ANDing
00001290  C445                     280      AND.W   D5,D2        * AND with the current opcode data
00001292  B47C 0E80                281      CMP.W   #$0E80,D2    * Result of mask should be 0E80 if code is JSR
00001296  6700 0038                282      BEQ     DO_JSR       * 
0000129A                           283      *WHAT ELSE CAN THIS BE? TBD 
0000129A                           284      
0000129A                           285  ;; Typical structure for these chunks:
0000129A                           286  
0000129A                           287  DO_NOP
0000129A  47F9 000012F0            288      LEA     S_NOP,A3    * Load the NOP string into A3 for WRITE subroutine
000012A0  1E3C 0001                289      MOVE.B  #1,D7       * Store key for op code for EA module
000012A4                           290      ** Eventually, EA Module will be called here
000012A4  4EB9 000012E2            291      JSR     WRITE       * Jump to WRITE subroutine
000012AA  4E75                     292      RTS                 * Return to I/O module 
000012AC                           293      
000012AC                           294  
000012AC                           295  DO_RTS
000012AC  47F9 000012F4            296      LEA     S_RTS,A3    * Load the RTS string into A3 for WRITE subroutine
000012B2  1E3C 001C                297      MOVE.B  #28,D7      * Store key for op code for EA module
000012B6                           298      ** Eventually, EA Module will be called here
000012B6  4EB9 000012E2            299      JSR     WRITE       * Jump to WRITE subroutine
000012BC  4E75                     300      RTS                 * Return to the I/O module bra op_decode
000012BE                           301      
000012BE                           302  DO_MOVE
000012BE  47F9 000012F8            303      LEA     S_MOVE,A3
000012C4  1E3C 0002                304      MOVE.B  #2,D7
000012C8                           305      ** Eventually, EA Module will be called here
000012C8  4EB9 000012E2            306      JSR     WRITE
000012CE  4E75                     307      RTS
000012D0                           308      
000012D0                           309  DO_JSR
000012D0  47F9 000012FD            310      LEA     S_JSR,A3
000012D6  1E3C 001B                311      MOVE.B  #27,D7
000012DA                           312      ** Eventually, NOCK will be called here
000012DA  4EB9 000012E2            313      JSR     WRITE
000012E0  4E75                     314      RTS
000012E2                           315     
000012E2                           316  WRITE   * Writes string pointed to by A3 to memory pointed to by A1
000012E2  224C                     317      MOVEA.L A4,A1     * Save the position of A1 before writing (for I/0)
000012E4                           318  WRITE_LOOP
000012E4  18DB                     319      MOVE.B  (A3)+,(A4)+     * Write one byte and increment
000012E6  0C13 0000                320      CMP.B   #0,(A3)         * Are we at the null terminator?
000012EA  66F8                     321      BNE     WRITE_LOOP      * If not, keep going
000012EC  18DB                     322      MOVE.B  (A3)+,(A4)+     * Write the null terminator before exiting
000012EE  4E75                     323      RTS                     * Executes once null terminator was reached
000012F0                           324      
000012F0                           325  ;; ~~~~~~~~STRING CONSTANTS~~~~~~~~
000012F0                           326  
000012F0  =00004E71                327  CODE_NOP    EQU     $4E71
000012F0  =00004E75                328  CODE_RTS    EQU     $4E75
000012F0                           329  
000012F0  =00002000                330  A4_PREV     SET     $2000
000012F0                           331  
000012F0= 4E 4F 50 00              332  S_NOP   DC.B    'NOP',0
000012F4= 52 54 53 00              333  S_RTS   DC.B    'RTS',0
000012F8= 4D 4F 56 45 00           334  S_MOVE  DC.B    'MOVE',0
000012FD= 4A 53 52 00              335  S_JSR   DC.B    'JSR',0
00001301                           336  
00001301  =00000E80                337  JSR_MASK    EQU     %0000111010000000
00001301                           338  ;; ~*~*~*~*~*~*~*~END OPCODE MODULE~*~*~*~*~*~*~*~
00001301                           339  
00001301                           340  
00001301                           341  -------------------- end include --------------------
00001301                           342      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A4_PREV             2000
ADDR_PRMPT_END      11E1
ADDR_PRMPT_STRT     11BE
ASC_CHAR_MAX        46
ASC_CHAR_MIN        41
ASC_NUM_MAX         39
ASC_NUM_MIN         30
ASC_TO_CHAR         109C
ASC_TO_NUM          1092
BUFFER              1230
CHECK_CHAR_MAX      1086
CHECK_CHAR_MIN      107A
CHECK_NUM_MAX       106C
CHECK_NUM_MIN       1060
CODE_NOP            4E71
CODE_RTS            4E75
COLON_SPACE         115B
CONVERSION_LOOP     105E
CR                  D
DISM_CODE           8000
DONE_MSG            1155
DO_JSR              12D0
DO_MOVE             12BE
DO_NOP              129A
DO_RTS              12AC
END_LTE_BEG         117B
END_NOW             1236
ERROR_END_LTE_BEG   10C2
ERROR_INV_INP       10B2
INVALID_INPUT       115E
JSR_MASK            E80
LF                  A
MAIN_LOOP           10D2
NEW_LINE            1152
OIOO_BRA            128C
OIOX_BRA            1284
OIXX_BRA            127C
OOOO_BRA            127C
OOOX_BRA            1274
OOXX_BRA            126C
OP_DECODE           1244
OXXX_BRA            1264
PRINT_IT            1104
PRINT_IT_LOOP       1110
PRINT_IT_STRING     1203
PRINT_LOOP          10DE
PRINT_NOPS_TEST     10E6
SHIFTS              10A6
START               1000
S_JSR               12FD
S_MOVE              12F8
S_NOP               12F0
S_RTS               12F4
WRITE               12E2
WRITE_LOOP          12E4
